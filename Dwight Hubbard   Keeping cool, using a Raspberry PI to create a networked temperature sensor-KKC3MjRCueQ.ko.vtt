WEBVTT
Kind: captions
Language: ko

00:00:00.130 --> 00:00:02.620
이번 발표자는 Dwight Hubbard 입니다.
라즈베리 파이를 사용하여 

00:00:02.620 --> 00:00:05.300
시원하게 온도를 유지해주는 
네트워크 온도 센서기기를 만들었습니다.

00:00:05.300 --> 00:00:07.120
박수 부탁드립니다.

00:00:07.120 --> 00:00:13.380
[applause]

00:00:13.380 --> 00:00:16.740
(Dwight Hubbard)
안녕하세요, 저는 Dwight Hubbard입니다.

00:00:16.740 --> 00:00:19.680
저는 Python 사용하는 것에 푹 빠져있습니다.

00:00:20.440 --> 00:00:23.960
이런, 이 화면이 아닌데.

00:00:26.520 --> 00:00:29.240
[laughter]

00:00:37.000 --> 00:00:38.640
Yeah. 

00:00:45.040 --> 00:00:47.620
Okay, 기술적 문제인가.

00:01:04.140 --> 00:01:05.760
아직 안되네요.

00:01:13.200 --> 00:01:15.000
음?

00:01:15.000 --> 00:01:16.540
여기는 제대로 보이네요.

00:01:16.540 --> 00:01:18.160
Oh okay.

00:01:20.880 --> 00:01:26.020
이분들이 작업하실 동안
우선 시작하겠습니다.

00:01:26.020 --> 00:01:28.090
말씀드렸던 것처럼 저는 Dwight Hubbard입니다.

00:01:28.090 --> 00:01:31.350
저는 사물인터넷(IoT)을 구현하는 것에 
푹 빠져있습니다.

00:01:31.350 --> 00:01:34.659
제가 말씀드리는 IoT는 
컴퓨터에 의해서 구동되는 하드웨어 장치를 

00:01:34.659 --> 00:01:38.299
의미합니다.

00:01:38.299 --> 00:01:40.799
그리고 저는 Python을 이용해서 
IoT를 구현하는 것에 푹 

00:01:40.799 --> 00:01:42.499
빠져있습니다.

00:01:42.500 --> 00:01:45.260
자, 그럼 Python으로 구동되는 
컴퓨터에 관해 이야기를 시작해보려 합니다.

00:01:46.820 --> 00:01:51.670
오늘 말씀드릴 내용은
온도 센서를 사용해서 IoT를 소개하기에 좋은

00:01:51.679 --> 00:01:56.170
라즈베리 파이에 대해서 말씀드리려고

00:01:56.170 --> 00:01:59.230
합니다.

00:02:00.980 --> 00:02:05.320
여러분, 수고하신 AV 분들에게 
박수 부탁드립니다.

00:02:05.320 --> 00:02:08.320
[applause]

00:02:08.329 --> 00:02:11.670
온도 센서에 대해서 말씀드리기 전에

00:02:11.670 --> 00:02:13.990
제가 키우는 고양이에 대해서 
잠시 말씀드리겠습니다.

00:02:16.420 --> 00:02:20.280
일반적으로 IoT 같은 프로젝트는

00:02:20.281 --> 00:02:24.800
프로젝트가.
화면이 또 파랗게 되었네요.

00:02:24.800 --> 00:02:26.720
[laughter]

00:02:27.800 --> 00:02:30.940
반면, 우리가 보통 뭔가를 목표를 달성하기 위해
시도를 하다가

00:02:30.950 --> 00:02:33.190
영감을 얻습니다.

00:02:34.420 --> 00:02:37.000
제 경우는, 맞습니다.
저는 고양이를 가지고 있습니다.

00:02:38.340 --> 00:02:40.280
사실 고양이를 1마리만 가질 수는 없습니다.

00:02:40.280 --> 00:02:43.700
저는 실제로 여러 마리의 고양이를 가지고 키우고 있습니다.

00:02:43.700 --> 00:02:46.340
화면 속의 고양이들,
이게 만약 보인다면,

00:02:46.340 --> 00:02:48.650
제 고양이가 영감을 가져다주었습니다.

00:02:48.650 --> 00:02:50.370
고양이의 이름은 카이아입니다.

00:02:50.370 --> 00:02:56.460
고양이와 함께 장거리 여행을 했었습니다.
그리고 아시다시피 반려동물과의 장거리 여행은

00:02:56.460 --> 00:02:59.640
Pit Stop을 해야 하는 상황에 부닥치게 됩니다.

00:03:00.640 --> 00:03:04.860
고양이를 집에 데려다줄 수 없고,
호텔에 체크인하지 못하는 상황에서도

00:03:04.860 --> 00:03:06.940
고양이를 안전하게 해주고 싶었습니다.

00:03:08.220 --> 00:03:13.000
그래서 저는 Python과 IoT 사용하는 것에
관심을 가지게 되었고,

00:03:13.000 --> 00:03:16.560
저는 이 문제들을 해결하기 위해
과도하게 설계하기로 했습니다.

00:03:16.560 --> 00:03:18.640
[laughter]

00:03:25.870 --> 00:03:29.250
화면이 금방 고쳐졌으면 좋겠어요.

00:03:30.850 --> 00:03:36.410
제가 한 첫 번째 일은 
라즈베리 파이를 사용하기로 한 것입니다.

00:03:36.410 --> 00:03:40.520
저는 한 뭉치의 라즈베리 파이를 
바닥에 쫙 깔았습니다.

00:03:40.520 --> 00:03:44.810
라즈베리 파이는 IoT를 사용하기에 좋습니다.

00:03:44.810 --> 00:03:48.950
그리고 그것들은 우리가 사용해왔던 개발 도구들을
사용할 수 있는 매우 강력한 컴퓨터

00:03:48.950 --> 00:03:51.130
입니다.

00:03:51.130 --> 00:03:54.390
그래서 이런 종류의 프로젝트를 수행하는데
아주 좋습니다.

00:03:56.660 --> 00:03:59.980
화면이 계속 이대로 잘 나왔으면 좋겠군요.

00:03:59.980 --> 00:04:03.210
우리가 IoT를 할 때 가장 먼저 해야 할 일은 
하드웨어를 선택해야 한다는 

00:04:03.210 --> 00:04:05.550
것입니다.

00:04:07.700 --> 00:04:09.300
이제 라즈베리 파이는.

00:04:09.300 --> 00:04:13.160
이런.
제가 화면을 넘길 때마다 다시 파란 화면이 되네요.

00:04:13.170 --> 00:04:16.920
라즈베리 파이는 각기 다른
하드웨어 컨넥션을 가지고 있습니다.

00:04:16.920 --> 00:04:19.290
IoT에 대해서,

00:04:19.290 --> 00:04:23.030
GPIO 커넥터라고 불리는
보드 상의 커넥터를 사용하는 것에 대해

00:04:23.030 --> 00:04:25.270
이야기하려고 합니다.

00:04:26.150 --> 00:04:31.190
이 커넥터는 라즈베리 파이에 직접 연결됩니다.

00:04:31.190 --> 00:04:35.150
요즘 시대의 컴퓨터는 거대한 스위치 네트워크일 뿐입니다.

00:04:36.620 --> 00:04:41.260
변수를 설정하면, 
실제 작동하는 것은

00:04:41.260 --> 00:04:45.790
커패시터라고 불리는 

00:04:45.790 --> 00:04:50.160
전하를 흐르게 하거나 막을 수 있는 스위치입니다.

00:04:51.760 --> 00:04:55.380
이 GPIO 커넥터를 사용하면
장치를 바로 그 커넥터 중 하나에 

00:04:55.380 --> 00:04:58.750
연결할 수 있습니다.
GPIO 커넥터에 연결한 스위치를 켜고,

00:04:58.750 --> 00:05:05.660
해당 GPIO의 위치에서 
변수와 같은 값을 확인하면

00:05:05.660 --> 00:05:10.120
스위치가 꺼져 있는지를 확인할 수 있을 것입니다.

00:05:12.790 --> 00:05:14.650
이것은 실제로 매우 강력합니다.

00:05:14.650 --> 00:05:19.180
왜냐하면, GPIO 헤더까지 
모든 전자 장치를 연결할 수 있기 때문입니다.

00:05:19.180 --> 00:05:20.830
다양한 컨버터가 필요할 수도 있지만

00:05:20.830 --> 00:05:23.770
이것을 이용해서 다른 많은 것들을 
연결할 수 있습니다.

00:05:23.770 --> 00:05:27.960
이는 다양한 크기와 성능을 가진
부품 중을 마음대로 선택할 수 있다는 것을

00:05:27.960 --> 00:05:30.020
의미합니다.

00:05:30.020 --> 00:05:32.560
마치 제가 요즘 사용하고 있는 
온도 센서와 같이 말이죠.

00:05:32.560 --> 00:05:35.930
어떤 버전은 방수가 되고
어떤 버전은 매우 높은 온도에서

00:05:35.930 --> 00:05:42.150
정상 동작이 가능하고,
어떤 버전은 매우 정확하게 측정할 수 있고,

00:05:42.150 --> 00:05:44.610
어떤 버전은 측정은 다소 정확하진 않지만, 
저렴합니다.

00:05:46.560 --> 00:05:52.220
그래서 염두에 두어야 할 몇 가지가 있습니다.

00:05:54.139 --> 00:05:56.790
라즈베리 파이의 전자 장치에 
직접 연결해서 

00:05:56.790 --> 00:05:59.490
사용합니다.

00:05:59.490 --> 00:06:01.590
그리고 그것은 정말 강력합니다.

00:06:03.669 --> 00:06:05.990
하지만 몇 가지 꼭 신경 써야 할 사항이 있습니다.

00:06:05.990 --> 00:06:08.710
그냥 꽂아서 사용하는 USB 버스와는 
좀 다르지만,

00:06:08.710 --> 00:06:10.600
대부분은 괜찮습니다.

00:06:10.600 --> 00:06:13.300
라즈베리 파이를 커넥터에 연결할 때

00:06:13.300 --> 00:06:15.120
아무런 안전장치가 없습니다.

00:06:16.169 --> 00:06:18.580
많은 유연성이 있지만,
주의를 기울여야 합니다.

00:06:18.580 --> 00:06:21.760
그렇지 않으면
라즈베리 파이에 손상을 주거나 망가질 수 있습니다.

00:06:22.840 --> 00:06:26.480
주의를 기울여서 사용한다면
아무런 문제가 없을 것입니다.

00:06:26.490 --> 00:06:31.450
저는 아직 라즈베리 파이를 태운 적은 없습니다.
하지만 제가 아는 몇몇 분은 태우셨죠.

00:06:32.760 --> 00:06:37.020
기본적으로 연결할 때, 
주의해야 할 3가지가 있습니다.

00:06:37.020 --> 00:06:42.320
라즈베리 파이 혹은 
라즈베리 파이의 GPIO 커넥터에 연결할 때,

00:06:42.320 --> 00:06:47.360
첫 번째 필요한 것은 
작동시키기 위한 3.3V 전압입니다.

00:06:47.360 --> 00:06:50.740
라즈베리 파이는 3.3V 컴퓨터입니다.

00:06:50.740 --> 00:06:54.080
이 부분은 중요합니다.
왜냐하면, 수십 년 동안

00:06:54.080 --> 00:06:58.180
컴퓨터는 전압이 0일 때는 0이고,

00:06:58.180 --> 00:07:01.740
5V인 경우 1을 나타내왔기 때문입니다.

00:07:03.050 --> 00:07:08.580
라즈베리 파이의 GPIO 핀은
5V를 못 견딥니다.

00:07:08.580 --> 00:07:12.750
만약 5V의 전압을 사용하게 되면
라즈베리 파이는 손상되거나 망가집니다.

00:07:13.700 --> 00:07:15.120
그래서 우리는.

00:07:15.120 --> 00:07:18.020
기본적으로 5V의 전압을 사용하지 않도록
주의해야 합니다.

00:07:18.020 --> 00:07:21.930
그래서 3.3V에서 작동하는 부품들이 필요합니다.

00:07:21.930 --> 00:07:26.530
또 다른 주의사항은
5V에서 동작하는 부품들이 

00:07:26.560 --> 00:07:28.640
정확히 5V에서 동작하지 않는다는 사실입니다.

00:07:28.640 --> 00:07:32.740
그것들은 일반적으로 전압의 일정한 범위를 가지고 있고
그 범위 안에서 작동합니다.

00:07:32.750 --> 00:07:37.820
일부 부품들은 3.3V보다 낮거나 
더 낮은 전압에서도 작동합니다.

00:07:37.820 --> 00:07:42.940
그래서 이런 부품들은 
5V를 사용하는 컴퓨터나 라즈베리 파이에서 동작합니다.

00:07:44.210 --> 00:07:46.919
그래서 반드시 사용할 부품의
규격서를 읽고 나서 사용해야 

00:07:46.919 --> 00:07:48.320
합니다.

00:07:48.320 --> 00:07:51.320
그리고 범용적으로 많이 사용되는 
기기를 사용하는 경우

00:07:51.320 --> 00:07:53.200
거의 모든 종류의 튜토리얼을 찾아볼 수 있습니다.

00:07:53.210 --> 00:07:55.120
“헤이, 이걸 라즈베리 파이에 연결했어.”

00:07:55.120 --> 00:07:57.160
그리고 이건 이렇게 작동해
라고 말이죠.

00:07:59.600 --> 00:08:03.669
그리고 부품은 디지털이어야 합니다.

00:08:03.669 --> 00:08:07.810
일부 전자 부품들은 전기가 그것들을 통해 흘러가고,

00:08:07.810 --> 00:08:14.680
얼마만큼의 전기가 흘러가는지에 따라서 
어떤 형태의 환경이 변하게 됩니다.

00:08:14.680 --> 00:08:18.600
예를 들면, 온도 센서는 온도에 따라 
전기의 흐름에 대해 각기 다르게 

00:08:18.600 --> 00:08:20.320
저항할 수 있으며,

00:08:20.320 --> 00:08:26.850
그리고 저항값으로 실제 온도를 측정할 수 있습니다.

00:08:26.850 --> 00:08:30.380
문제는, 
라즈베리 파이에는 전압을 측정하는 회로가 없다는 

00:08:30.380 --> 00:08:31.760
것입니다.

00:08:31.760 --> 00:08:33.520
그리고 다음과 같은 타입의 부품은 사용할 수 없습니다.

00:08:33.520 --> 00:08:36.380
그것은 아날로그 부품이라고 부르는 것들입니다.

00:08:36.380 --> 00:08:38.690
최소한 라즈베리 파이에 직접 사용할 수는 없습니다.

00:08:38.690 --> 00:08:43.390
실제 전압을 측정할 수 있는 회로를 추가한 다음

00:08:43.390 --> 00:08:45.310
그 아날로그 부품들을 사용할 수 있습니다.

00:08:45.310 --> 00:08:50.230
그러나 이 경우, 
이러한 아날로그 부품 중의 하나는

00:08:50.230 --> 00:08:53.290
디지털 온도 센서보다 훨씬 비쌉니다.

00:08:55.200 --> 00:08:59.630
그리고 마지막 3번째는
이 부품들의 상태가 변하고 

00:08:59.630 --> 00:09:03.230
0과 1을 전송한다는 것을 기억해야 합니다.

00:09:03.230 --> 00:09:06.730
그것으로 GPIO 핀을 켜거나 끕니다.

00:09:06.730 --> 00:09:10.390
분명한 건 스위치일 경우에는
매우 쉽습니다.

00:09:10.390 --> 00:09:14.390
그러나 만약 온도 정보를 수집한다면
온도 정보를 전송하는데

00:09:14.390 --> 00:09:17.690
어떤 코드가 사용되는지
파악해야 합니다.

00:09:17.690 --> 00:09:19.460
우리는 그것을 해독(decode)할 필요가 있습니다.

00:09:19.460 --> 00:09:21.200
요즘 부품 설명 문서에는
이런 정보들이 포함되어 있지만

00:09:21.200 --> 00:09:23.100
대다수의 경우 문서는

00:09:23.100 --> 00:09:25.580
복잡합니다.

00:09:25.580 --> 00:09:29.600
그래서 우리가 일반적으로 필요로 하는 것은,
누군가 대신 소프트웨어 드라이버나,

00:09:29.600 --> 00:09:32.300
부품이 실제 우리에게 전송해주는 데이터를 
해석(decode)해주는 소프트웨어를 

00:09:32.300 --> 00:09:37.940
만들어 주기를 바랍니다.

00:09:37.940 --> 00:09:41.230
만약 이 3가지를 찾을 수만 있다면

00:09:41.230 --> 00:09:45.380
쉽게 라즈베리 파이를 연결해서 사용할 수 있습니다.

00:09:45.380 --> 00:09:50.570
자, 제가 프로젝트에서 했던 것을
살펴보겠습니다.

00:09:50.570 --> 00:09:53.570
이것은 제가 사용하는 온도 센서입니다.

00:09:53.570 --> 00:09:58.370
이것은 Dallas Semiconductor DS18B20으로

00:09:58.370 --> 00:10:00.180
Maxim Semiconductors에서 샀습니다.

00:10:00.180 --> 00:10:01.660
그래서 이것은 Maxim/Dallas입니다.

00:10:01.660 --> 00:10:03.540
이것은 어느 쪽에서든 볼 수 있습니다.

00:10:05.540 --> 00:10:10.940
제가 가져온 것의 1번째 체크포인트는
3.3V에서 동작하는지 여부입니다.

00:10:10.950 --> 00:10:14.120
문서상 이 부품은

00:10:14.120 --> 00:10:16.490
3~5.5V 사이에서 작동합니다.

00:10:16.490 --> 00:10:19.890
3.3V는 중간이고 
실제로 중간보다 낮지만

00:10:19.890 --> 00:10:21.860
3~5.5V 범위 안에 있습니다.

00:10:21.860 --> 00:10:26.630
이 부품은 최소한 
우리가 요구하는 전압에서 작동합니다.

00:10:26.630 --> 00:10:29.430
2번째는 디지털이어야 합니다.

00:10:29.430 --> 00:10:34.800
이 부품은 직렬 프로토콜을 사용합니다.

00:10:34.800 --> 00:10:39.820
직렬 프로토콜은 기본적으로 
0과 1을 잇달아 전송하는 것을 의미합니다.

00:10:39.820 --> 00:10:42.820
모스 부호처럼.

00:10:42.820 --> 00:10:47.210
그래서 기본적으로 온도가 어떤지를 코드로 전송합니다.

00:10:47.210 --> 00:10:50.600
하지만 껐다 켰다 하면서 사용하기 때문에
이것은 디지털 프로토콜입니다.

00:10:50.600 --> 00:10:52.860
그래서 이것은 라즈베리 파이와 함께 사용할 수 있습니다.

00:10:53.940 --> 00:10:58.380
3번째는 라즈베리 파이에서 가장 일반적으로 사용되는
운영체제인

00:10:58.380 --> 00:11:01.350
Raspbian 배포판입니다.

00:11:01.350 --> 00:11:03.450
드라이버가 내장되어있고, 이는
실제로 배포판에 포함되어

00:11:03.450 --> 00:11:05.040
있습니다.

00:11:05.040 --> 00:11:09.400
이제 우리는 디코딩해줄 소프트웨어가 있고
드라이버도 가지고 있습니다.

00:11:11.670 --> 00:11:15.209
그리고 이 센서에 대해서 주목할 몇 가지 사항이 있습니다.

00:11:15.209 --> 00:11:18.920
이는 실제 라즈베리 파이를 연결하는데 
도움이

00:11:18.920 --> 00:11:20.240
됩니다.

00:11:20.240 --> 00:11:22.040
우선 센서는 2개의 면이 있습니다.

00:11:22.040 --> 00:11:25.240
여기 사진상으로 볼 수 있듯이

00:11:25.240 --> 00:11:27.830
한쪽 면은 평평합니다.

00:11:27.830 --> 00:11:32.029
보이지 않는 뒷면은 둥글게 처리되어있습니다.

00:11:32.029 --> 00:11:36.850
이 부분은 주목해야 합니다.
왜냐하면, 실제 어느 쪽을 연결해야 하는지 

00:11:36.850 --> 00:11:39.540
알아야 하기 때문입니다.

00:11:39.540 --> 00:11:42.310
그리고 이에 대한 
데이터 시트(diagram datasheet)가 있습니다.

00:11:42.310 --> 00:11:46.560
그러나 어느 쪽이 본인을 향해있는지 모를 경우

00:11:46.560 --> 00:11:49.649
데이터 시트를 보고 부품을 
장치와 어떻게 연결해야 하는지

00:11:49.649 --> 00:11:51.279
알 수 없습니다.

00:11:51.279 --> 00:11:54.620
그래서 부품은 평평한 면, 

00:11:54.620 --> 00:11:56.880
혹은 일종의 노치(notch), 

00:11:56.880 --> 00:12:01.709
혹은 큰 부품인 경우 모든 핀에 라벨로 표시되어있습니다.

00:12:01.709 --> 00:12:07.100
그러나 여러분께 알려드리고 싶은 것이 있습니다.
제가 데이터 시트 문서와 센서를 어떻게

00:12:07.100 --> 00:12:10.220
어떻게 맞출까요?

00:12:10.220 --> 00:12:14.529
지금 같은 경우, 
평평한 면을 마주하고,

00:12:14.529 --> 00:12:16.469
센서의 다리는 아래를 향하게 합니다.

00:12:18.550 --> 00:12:22.200
이것은 아주 흔한 센서 장치입니다.

00:12:22.200 --> 00:12:25.140
일반적으로 GPIO 핀에 연결하는 모든 장치는

00:12:25.140 --> 00:12:27.240
전원이 필요합니다.

00:12:27.240 --> 00:12:31.080
그리고 전원은 전기의 흐름에 의해서 생성됩니다.

00:12:31.080 --> 00:12:34.200
전기는 +에서 -나 

00:12:34.200 --> 00:12:37.500
더 낮은 전하 쪽으로 흐릅니다.

00:12:37.500 --> 00:12:40.029
전기를 흐르게 하려면

00:12:40.029 --> 00:12:44.220
전기가 드나들 수 있는 곳이 필요합니다.

00:12:44.220 --> 00:12:47.570
온도 센서의 다리 중 2개가 전원용입니다.

00:12:47.570 --> 00:12:52.170
하나는 3V 전원 입력용이고, 
하나는 -극 또는 전원 출력하는

00:12:52.170 --> 00:12:56.340
접지용입니다.

00:12:56.340 --> 00:12:59.240
거의 모든 센서 장치가 라즈베리 파이의 
GPIO 핀에 연결할

00:12:59.240 --> 00:13:03.160
2개의 전원용 다리를 가지고 있습니다.

00:13:05.000 --> 00:13:07.400
마지막으로 보셔야 할 세 번째 다리입니다.

00:13:07.410 --> 00:13:09.890
세 번째 다리는 1과 0의 정보를 전송합니다.

00:13:09.890 --> 00:13:14.410
우리가 온도정보를 읽을 수 있도록 말이죠.

00:13:17.400 --> 00:13:23.720
그래서 다음은, 이것을 어떻게 연결하는지에 대해서
알아보겠습니다.

00:13:23.730 --> 00:13:26.709
그러기 위해서 또 다른 부품 하나를 사용해야 합니다.

00:13:26.709 --> 00:13:31.820
이 사진 속의 플라스틱 보드입니다.
빵판(브레드보드)이라고 불리는.

00:13:31.820 --> 00:13:36.640
빵판은 아마도 전자 관련 프로젝트에서는 
프로토타입을 제작하기 위한 가장 보편적인 보드일 것입니다.


00:13:36.650 --> 00:13:39.510
플라스틱 보드에 구멍들이 있습니다.

00:13:39.510 --> 00:13:41.590
2개의 방향이 있습니다.

00:13:42.660 --> 00:13:47.460
같은 행에 있는 모든 구멍은 서로 연결되어있습니다.

00:13:47.470 --> 00:13:49.930
구멍 안에 스프링이 달린 커넥터가 있어서

00:13:49.930 --> 00:13:52.450
선을 꽂으면 이를 단단히 고정해줍니다.

00:13:52.450 --> 00:13:56.800
그러다 보니 선이 쉽게 뽑히지는 않습니다.

00:13:56.800 --> 00:14:00.410
따라서 2개의 부품을 서로 연결하기 위해서는

00:14:00.410 --> 00:14:03.040
빵판의 같은 행에 
선을 꽂아서 서로 연결해주어야 합니다. 

00:14:03.040 --> 00:14:05.000
그리고 만약 다른 것을 만들고 싶다면

00:14:05.000 --> 00:14:07.920
우리는 그저 선을 뽑고 
다시 사용하면 됩니다.

00:14:07.920 --> 00:14:11.990
그래서 이것은 정말 쉽고 빠르게 프로토타입을
만들어 볼 수 있습니다.

00:14:11.990 --> 00:14:15.300
IoT 프로젝트를 진행할 때, 
납땜과 같은 것들을 하는 데 시간을 허비할 

00:14:15.300 --> 00:14:20.480
필요가 없습니다.

00:14:20.480 --> 00:14:24.080
2번째로는, 
라즈베리 파이를 빵판에 연결하는 선이 필요

00:14:24.089 --> 00:14:26.089
합니다.

00:14:26.800 --> 00:14:32.620
마지막으로, 
이 센서는 4.7k의 저항이 필요합니다.

00:14:32.620 --> 00:14:38.340
이 4.7k 저항은 센서와 핀 사이에 위치해야 

00:14:38.340 --> 00:14:40.580
합니다.

00:14:41.769 --> 00:14:47.610
이러한 것들을 염두에 두고, 
여기 라즈베리 파이 사진을 봐주세요.

00:14:47.610 --> 00:14:50.950
이것은 실제로 전선들이 연결된 모습입니다.

00:14:50.950 --> 00:14:55.980
이 그림에서 라즈베리 파이의 방향을 
알아챌 수 있으실 것입니다.

00:14:55.980 --> 00:15:02.230
부품의 핀, GPIO핀, 전선들이
오른쪽 위 모서리 쪽에 있고

00:15:02.230 --> 00:15:04.370
우리가 내려다보고 있는 것을 알 수 있습니다.

00:15:04.370 --> 00:15:07.180
우리가 사용하고 있는 센서와 마찬가지로
그 핀이 무엇인지 알 수 있도록 방향을 잡아야

00:15:07.180 --> 00:15:10.120
합니다.
왜냐하면, 라즈베리 파이를 거꾸로 보고 있다면

00:15:10.120 --> 00:15:14.930
우리는 전선을 반대로 잘 못 꽂을 수 있기 때문입니다.

00:15:14.930 --> 00:15:17.080
그리고 그렇게 반대로 꽂는 건 정말 최악입니다.

00:15:17.800 --> 00:15:21.100
자 그럼,
첫 번째 우리가 할 것은 

00:15:21.100 --> 00:15:23.130
빵판에 센서를 꽂는 것이겠죠?

00:15:23.130 --> 00:15:27.370
선으로 연결하려고
그것을 빵판에 꽂습니다.

00:15:27.370 --> 00:15:32.060
두 번째는 전원 연결입니다.

00:15:32.060 --> 00:15:36.649
전선이 있으면 
핀의 열(row) 옆에 뭐가 있는지 

00:15:36.649 --> 00:15:38.220
보기가 어렵습니다.

00:15:38.220 --> 00:15:42.190
실제로 각 핀이 무엇인지 알 수 있도록 해주는
작은 범례가 있습니다.

00:15:42.190 --> 00:15:49.209
첫 번째로 해야 할 것은,
빨간색 전선은 3.3V 핀에 연결됩니다.

00:15:49.209 --> 00:15:52.360
이것이 3V 전원 핀입니다.

00:15:52.360 --> 00:15:56.690
이 핀은 3.3V의 전원을 가지고 있습니다.

00:15:56.690 --> 00:16:00.320
따라서 이 핀은 2곳으로 연결되어야 합니다.

00:16:00.320 --> 00:16:04.200
하나는 센서의 전원과 연결해야 합니다.

00:16:04.200 --> 00:16:09.149
그리고 전원과 핀 사이에 두어야 할 저항이 필요

00:16:09.149 --> 00:16:12.029
합니다.

00:16:12.029 --> 00:16:14.149
그래서 비어있는 행에 이것을 연결합니다.

00:16:15.660 --> 00:16:17.540
다음으로 다른 전선을 집어서

00:16:17.550 --> 00:16:21.950
방금 연결했던 것과 같은 행에 
꽂습니다.

00:16:21.950 --> 00:16:27.070
그러면 센서의 전원 핀과 같은 행에 
연결되게 됩니다.

00:16:27.070 --> 00:16:31.810
이제 센서는 라즈베리 파이의 GPIO에 전원에
연결되었습니다.

00:16:33.520 --> 00:16:37.280
다음은 전원의 반환에 대해 말씀드리겠습니다.

00:16:37.290 --> 00:16:39.649
반환된 전압, 0V

00:16:39.649 --> 00:16:43.589
혹은 뭐라고 부르든 간에 
보통은 접지라고 부릅니다.

00:16:43.589 --> 00:16:47.520
지금은 중요한 기술적인 이유가 있긴 하지만
일반적으로

00:16:47.520 --> 00:16:52.209
라즈베리 파이에 있는
GPIO 커넥터에는

00:16:52.209 --> 00:16:54.440
여러 개의 접지 핀이 있습니다.

00:16:54.440 --> 00:16:55.860
그것들은 모두 연결되어있습니다.

00:16:55.860 --> 00:16:58.760
그래서 어떤 것을 사용해도 상관없습니다.

00:16:58.770 --> 00:17:01.230
전선이 (아래 핀이 보이는 것을) 방해하지 못하게 
하나를 골라냈습니다.

00:17:01.230 --> 00:17:04.760
그래서 여전히 범례를 읽을 수 있습니다.

00:17:04.760 --> 00:17:06.890
그러나 라즈베리의 접지 핀에 선을 

00:17:06.890 --> 00:17:09.220
연결하고,

00:17:09.220 --> 00:17:12.610
센서의 (-)극 커넥터가 있는 행에 

00:17:12.610 --> 00:17:15.270
다른 쪽 끝을 연결합니다.

00:17:18.360 --> 00:17:23.380
마지막으로, 
저항을 가져와서 전원과 같은 행에 연결합니다.

00:17:23.390 --> 00:17:25.330
그리고 센서의 행과도 연결합니다.

00:17:26.819 --> 00:17:30.890
그런 다음 센서의 데이터를 제공해 줄
가운데 핀에 

00:17:30.890 --> 00:17:36.190
4라고 표기된 핀에 연결합니다.

00:17:37.620 --> 00:17:40.690
번호가 매겨진 핀은 일반적으로 
입/출력을 수행하는 핀입니다.

00:17:40.690 --> 00:17:45.640
그것들은 우리가 곧 조작하려고 하는 것들입니다.

00:17:45.640 --> 00:17:50.670
이처럼 센서의 핀은 
라즈베리 파이와 직접 연결되었습니다.

00:17:50.670 --> 00:17:53.520
그리고 이제 4번 핀을 사용합니다.
왜냐하면, 우리가 사용하려는 드라이버가 

00:17:53.520 --> 00:17:57.730
4번 핀을 기본으로 사용하기 때문입니다.

00:17:57.730 --> 00:18:01.320
만약 다른 핀을 사용하고 싶은 경우,
드라이버를 재설정해줘야 합니다.

00:18:01.320 --> 00:18:06.500
그렇게 하는 것은 어렵지 않지만
될 수 있으면 기본값을 사용하시기를 권장합니다.

00:18:07.570 --> 00:18:13.510
소프트웨어에 대해 말씀드리기 전에,
제가 얻은 작은 교훈에 대해 먼저 말씀드리겠습니다.

00:18:13.510 --> 00:18:18.330
제가 온도 센서용 소프트웨어의
첫 번째 버전을 개발했을 때의 일입니다.

00:18:18.330 --> 00:18:23.790
첫 번째 소프트웨어는 온도 데이터를 저장하기 위해서
SQLite Python 모듈을 사용

00:18:25.140 --> 00:18:27.100
했었습니다.

00:18:27.110 --> 00:18:32.490
그리고 저는 매우 정확한 타이밍이 필요했기 때문에

00:18:32.490 --> 00:18:36.870
온도 데이터를 매우 자주 저장했었습니다.

00:18:36.870 --> 00:18:38.870
그러다 보니 문제가 있었습니다.

00:18:40.260 --> 00:18:42.840
라즈베리 파이의 SD card 같은 저장소는

00:18:42.840 --> 00:18:45.760
그것을 사용할 수 있는
용량이 제한되어 있습니다.

00:18:47.320 --> 00:18:50.900
그리고 더 최악인 것은
SQLite 같은 데이터베이스는

00:18:50.900 --> 00:18:56.880
전반적으로 데이터의 무결성을
중요시합니다.

00:18:56.880 --> 00:18:59.520
다시 말씀드리면, 
이것들은 데이터를 쓰면 

00:18:59.530 --> 00:19:01.820
데이터가 쓰였는지 확인합니다.

00:19:01.820 --> 00:19:05.679
그러다 만약 중간에 인터럽트가 발생하면,

00:19:05.679 --> 00:19:08.200
원상 복귀시킬 수 있습니다.

00:19:08.200 --> 00:19:11.100
문제는 이를 구현하기 위해서

00:19:11.100 --> 00:19:16.120
실제로 데이터를 추가할 때마다
여러 번 SD card에 써야 합니다.

00:19:17.780 --> 00:19:22.420
이러한 데이터의 추가는
SD card를 많이 쓰게 됩니다.
(일반적인 SD card는 write 횟수 제한이 있음) 

00:19:22.420 --> 00:19:25.260
최초 버전을 실행해두고
약 1달 동안 그것을 잊어버리고 떠났다가 

00:19:25.260 --> 00:19:27.780
되돌아 왔습니다.

00:19:27.780 --> 00:19:32.220
그리고 물론 모든 종류의 SD card 에러가 
발생했었습니다.

00:19:32.220 --> 00:19:35.809
그 에러 로그 정보를 가져올 수는 없었습니다
왜냐하면 

00:19:35.809 --> 00:19:39.190
제가 SD card에 로그를 기록했었고, 
그것이 망가져 버렸기 때문입니다.

00:19:39.190 --> 00:19:40.830
SD card는 완전히 망가져 버렸습니다.

00:19:40.830 --> 00:19:43.500
더는 사용할 수 없게 되었습니다.

00:19:43.500 --> 00:19:46.630
또 다른 하나는
저는 이것을 사용해서 사람들에게 가르쳐주고 싶었고,

00:19:46.630 --> 00:19:50.380
어떻게 사용하는지 사람들에게 보여주고 싶었습니다.

00:19:50.380 --> 00:19:53.920
그리고 SQLite는 
구조화된 쿼리를 사용해서

00:19:56.880 --> 00:19:58.720
사용하기 조금 어렵습니다.

00:19:58.730 --> 00:20:01.919
그래서 저는 바꿨습니다.
우선 첫 번째로 SD card의 수명을

00:20:01.919 --> 00:20:04.419
고려해야 합니다.

00:20:04.420 --> 00:20:08.860
SQLite를 이용해서 데이터를 전보다 적게 기록시켜서

00:20:08.860 --> 00:20:13.720
기본적으로 문제를 해결할 수는 있었습니다.

00:20:13.730 --> 00:20:16.090
그러나 저는 기술을 바꿔보기로 
결정했습니다.

00:20:16.090 --> 00:20:18.679
저는 이것을 실제 업무에서도 
많이 사용합니다.

00:20:18.679 --> 00:20:21.500
Redis라고 불리는 기술입니다.

00:20:21.500 --> 00:20:27.070
제가 Redis로 전환한 이유는
Redis가 일반적으로 성능을 강조해서입니다.

00:20:27.070 --> 00:20:32.030
그리고 성능을 높이기 위해서
실행 중인 프로그램이 메모리(RAM)에 데이터를

00:20:32.030 --> 00:20:34.860
저장합니다.

00:20:34.860 --> 00:20:40.549
이것은 플래시 메모리나 SD card에 기록하지만,

00:20:40.549 --> 00:20:42.829
정말 자주, 과감하게 구성할 수도 있습니다.

00:20:45.580 --> 00:20:50.160
Redis는 또한 우리의 데이터를 다른 컴퓨터에 
매우 쉽게 복제(replication)할 수 있는 
기능을 지원합니다.

00:20:50.160 --> 00:20:52.701
만약 라즈베리 파이가 배터리를 사용하고 있다면
정말로 

00:20:52.701 --> 00:20:54.950
좋습니다.

00:20:54.950 --> 00:20:59.480
보통은 직접 가서 고장 난 것을 
고치는 것은 좋아하지 않습니다.

00:20:59.480 --> 00:21:01.560
방전되기 전에 기록된 실제 데이터를 

00:21:01.560 --> 00:21:03.840
가지고 말이죠.

00:21:06.240 --> 00:21:09.640
가장 좋은 점은 Python을 좀 알고 있다면
배우기가 매우 쉽다는 점 

00:21:09.650 --> 00:21:11.480
입니다.

00:21:11.480 --> 00:21:17.140
그 이유는 Redis가 원격지 딕셔너리 서버를
의미하기 때문입니다.

00:21:17.140 --> 00:21:19.640
딕셔너리가 무엇인지 얼마나 
알고 계십니까?

00:21:20.559 --> 00:21:26.419
맞습니다. 지금 이야기하려는 것은 —
main 프로그램과는 별도로 딕셔너리를 저장하는

00:21:26.419 --> 00:21:29.250
프로그램입니다.

00:21:29.250 --> 00:21:33.530
이들 딕셔너리는 리스트, 스트링, set
그리고 다른 타입의 데이터를 가질 수 있습니다.

00:21:33.530 --> 00:21:38.650
우리에게 익숙한.

00:21:38.650 --> 00:21:41.580
그래서 만약 Python의 컨셉에 
익숙하시다면

00:21:41.580 --> 00:21:45.400
일반적으로 Redis를 이해하기 매우 쉽다는 것을 
알게 되실 것입니다.

00:21:47.289 --> 00:21:49.470
그럼, 이 소프트웨어 모듈을 설정하기 위해

00:21:49.470 --> 00:21:53.010
저는 3가지 Python 모듈을 사용합니다.

00:21:53.010 --> 00:21:57.130
redislite 모듈,
redis-collections 모듈,

00:21:57.130 --> 00:21:59.059
bottle 모듈.

00:21:59.059 --> 00:22:00.830
제가 사용하고 있는 구성요소 하나하나는

00:22:00.830 --> 00:22:02.380
pip로 인스톨이 가능하거나

00:22:02.380 --> 00:22:06.120
Raspbian Raspberry Pi 배포판에 
포함되어 있습니다.

00:22:07.720 --> 00:22:09.740
이제 센서와 서로 연결했습니다.

00:22:10.940 --> 00:22:13.900
이제 이것을 사용하기 위한 코드를 작성해야 합니다.
그래서 우리는 그것을 실제로 볼 수 있습니다.

00:22:13.900 --> 00:22:16.280
자, 
이제 여기서 뭔가를 보여 드리겠습니다.

00:22:21.720 --> 00:22:23.740
뭐냐면… 아!

00:22:25.460 --> 00:22:27.260
그렇지

00:22:31.220 --> 00:22:33.520
Thank you, Jupyter guys.

00:22:36.690 --> 00:22:39.810
그래서 우리가 사용하게 될 드라이버는
커널 드라이버라고 불리는 것입니다.

00:22:39.810 --> 00:22:45.450
그리고 이게 무엇을 할 것이냐면, 
이것은 가상 파일을 만들 것입니다.

00:22:46.570 --> 00:22:48.940
이것을 실제 확인해야 할 파일입니다.

00:22:48.940 --> 00:22:52.090
대략 이렇게 생겼습니다.
많은 알아볼 수 없는 값들과 같이 있습니다.

00:22:52.090 --> 00:22:54.860
그러나 파일에서 키포인트는

00:22:54.860 --> 00:22:58.350
‘t=‘과 값이 있는 부분입니다.

00:22:58.350 --> 00:23:01.750
이 값은 센서가 읽어 들인
온도의 실제 값에

00:23:01.750 --> 00:23:04.110
1000을 곱한 값입니다.

00:23:04.789 --> 00:23:08.570
그래서 파일을 열어서 온도 데이터를 위해 
필요한 것은

00:23:08.570 --> 00:23:11.580
숫자 값을 가져오고
float 형으로 변환하는 것입니다.

00:23:11.580 --> 00:23:13.540
그리고 1000으로 나눕니다.

00:23:14.620 --> 00:23:17.980
여기 아주 간단한 코드가 있습니다.

00:23:17.980 --> 00:23:20.380
read_temp_c라고 부르는 함수가 있습니다.

00:23:20.380 --> 00:23:22.750
파일을 엽니다.

00:23:22.750 --> 00:23:25.770
파일에서 ‘t=‘가 있는 라인을 찾습니다.

00:23:25.770 --> 00:23:28.380
‘=‘뒤에 있는 숫자를 가져온 후에

00:23:28.380 --> 00:23:31.480
1000으로 나눠주고 그 값을 반환해줍니다.

00:23:32.680 --> 00:23:34.160
엄청 간단합니다.

00:23:34.160 --> 00:23:37.120
그리고 실제로 온도 센서에서
데이터를 읽는 데 필요한 모든 작업이 수행

00:23:37.120 --> 00:23:39.000
됩니다.

00:23:39.000 --> 00:23:42.770
자, 이제 우리는 온도 정보를 가져올 수 있지만
이것을 저장할 필요가 있습니다.

00:23:42.770 --> 00:23:44.919
왜냐하면, 우리는 이것을 가지고 
무언가를 하고 싶어 하기 때문입니다.

00:23:44.919 --> 00:23:47.280
얼마나 온도가 빨리 올라갔는지,
평균 온도는 어떻게 되는지,

00:23:47.280 --> 00:23:49.159
등등.

00:23:49.159 --> 00:23:52.169
그래서 이 부분이 Redis를 도입한 지점입니다.

00:23:52.169 --> 00:23:55.289
바로 여기서 Redis 서버에 연결합니다.

00:23:55.289 --> 00:23:57.540
그러면 연결 오브젝트를 가져올 수 있습니다.

00:23:57.540 --> 00:24:01.080
그리고 Redis에 이 파일에 온도 데이터를
저장하라고 알립니다.

00:24:01.080 --> 00:24:03.840
제가 말씀드렸다시피
약 15분마다 그렇게 하게 될 것입니다.

00:24:05.120 --> 00:24:07.210
그리고 우리는 이것이 
네트워크에 연결되었으면 합니다.

00:24:07.210 --> 00:24:10.690
Redis는 실제로 작동하기 위해
네트워크상에 있지 않아도 됩니다.

00:24:10.690 --> 00:24:12.580
그리고 기본 설정도 그렇지 않습니다.

00:24:12.580 --> 00:24:14.370
그러나 잠시 후에 우리는 네트워크를 
사용하게 될 것입니다.

00:24:14.370 --> 00:24:16.360
그리고 물론 여러분의 네트워크상에 있는 
Redis 서버에 연결하려면

00:24:16.360 --> 00:24:18.860
아마도 비밀번호가 필요할지도 모르겠습니다.
그래서 암호를 하나 정해야 합니다.

00:24:20.060 --> 00:24:25.000
다음으로 Redis-collections라는
list object 모듈을 사용합니다.

00:24:25.000 --> 00:24:31.409
Redis 연결을 전달하고 
키 이름을 정합니다.

00:24:31.409 --> 00:24:37.179
그리고 객체를 반환합니다.

00:24:37.179 --> 00:24:40.599
Python 객체처럼 동작하지만
Redis 서버의 해당 키에 데이터를 저장하는

00:24:41.960 --> 00:24:44.180
이 부분을 주목하셔야 합니다.
왜냐하면, Redis 서버는

00:24:44.190 --> 00:24:49.590
데이터를 제공해주기 때문입니다.

00:24:49.590 --> 00:24:51.669
이 데이터는 Redis 서버에 저장될 것입니다.

00:24:51.669 --> 00:24:56.799
그러나 또한 Redis는 동일한 것에 접근하기 위한
별도의 스크립트를 작성할 수 있게 

00:24:56.799 --> 00:24:59.199
해줍니다.

00:24:59.200 --> 00:25:02.480
마지막으로 이것을 연결하기만 하면
온도 정보를 읽을 수 있고

00:25:04.040 --> 00:25:06.100
리스트에 추가(append)시킵니다.

00:25:08.060 --> 00:25:09.720
그걸로 끝입니다.

00:25:09.720 --> 00:25:11.679
그리고서 1초 쉬었다가 다시 읽습니다.

00:25:11.679 --> 00:25:14.159
그래서 온도를 1초 간격으로 읽을 수 있습니다.

00:25:19.460 --> 00:25:24.419
그리고 이것을 실행시키면 
온도 정보를 가져와서 볼 수 있을 것입니다.

00:25:24.419 --> 00:25:28.810
왜냐하면, 제가 시연할 라즈베리 파이가
여기 있기 때문입니다.

00:25:28.810 --> 00:25:30.830
온도 센서에 제 손가락을 가져다 대면,

00:25:30.830 --> 00:25:32.680
제 몸이 이곳 온도보다 높아서

00:25:32.680 --> 00:25:36.380
온도 값이 올라가는 것을 볼 수 있습니다.

00:25:36.390 --> 00:25:39.520
그리고 손가락을 떼면
온도가 감소하기 시작합니다.

00:25:39.520 --> 00:25:41.380
이제 온도 정보를 로그에 기록합니다.

00:25:41.380 --> 00:25:46.480
이제 완전하게 전원이 들어온 
라즈베리 파이 온도 정보 저장 장치가 되었습니다.

00:25:46.480 --> 00:25:48.180
정말 멋집니다.

00:25:48.180 --> 00:25:50.360
불과 20분 만에 다 했습니다.

00:25:53.510 --> 00:25:57.790
일반적으로 우리는 웹 인터페이스를 선호합니다.

00:26:02.380 --> 00:26:04.130
그럼 어떻게 해볼 수 있을까요?

00:26:04.130 --> 00:26:06.580
저는 bottle 라이브러리를 사용합니다.

00:26:06.580 --> 00:26:11.980
왜냐하면, 이 라이브러리는 제가 알고 있는 
가장 작은 Python 웹 프레임웍이기 때문입니다.

00:26:11.980 --> 00:26:13.780
그래서 이 라이브러리를 이용하면
이 많은 것들을 한 화면에 담을 수 

00:26:13.789 --> 00:26:16.420
있습니다. (코드 라인 수가 적음)

00:26:16.420 --> 00:26:19.100
이건 아주 간단한 
웹 UI입니다.

00:26:19.100 --> 00:26:21.470
동일한 Redis 연결을 사용할 것입니다.

00:26:21.470 --> 00:26:24.360
같은 리스트 객체에 접근할 것이고

00:26:24.360 --> 00:26:27.940
Redis 서버에서 같은 리스트의 키에 접근하고 있습니다.
그래서 이 로거(logger)는

00:26:27.940 --> 00:26:33.280
1분 전에 실행했던 것이 여전히 1초마다 데이터를
기록하고 있다는 것을 의미합니다.

00:26:33.280 --> 00:26:35.560
가장 최근에 읽어서 기록한 온도 정보가

00:26:35.560 --> 00:26:38.500
가장 마지막 아이템으로 기록되어있습니다.
왜냐하면, 이건 계속 추가(append)하기 때문이죠.

00:26:41.640 --> 00:26:43.340
그리고 우리는 route를 정합니다.

00:26:43.350 --> 00:26:48.679
그래서 우리가 이렇게 하면 
route는 

00:26:48.679 --> 00:26:51.289
온도를 읽었던 횟수를 보내줍니다.
왜냐하면, 이것은

00:26:51.289 --> 00:26:55.390
리스트의 길이를 알려주고

00:26:55.390 --> 00:26:58.350
이 길이는 가장 최근에 읽었던 온도의
가장 마지막 리스트 정보이기 때문입니다.

00:27:00.540 --> 00:27:04.160
그리고 bottle을 실행하고 나면
웹서버가 기동될 것입니다.

00:27:07.840 --> 00:27:12.280
기동된 웹 서버를 가지고,
2098번 읽었다는 것을 볼 수 있습니다.

00:27:13.800 --> 00:27:16.360
모르겠네요, 왜 안 뜨는지.

00:27:16.370 --> 00:27:19.640
물론 페이지를 갱신하면,
읽어 들인 온도의 숫자가 변하는 것을 볼 수 

00:27:19.640 --> 00:27:22.120
있습니다.

00:27:22.120 --> 00:27:28.080
이제 우리는 온도 센서가 정보를 기록하고, 
웹 서버도 가지고 있습니다.

00:27:30.480 --> 00:27:33.000
약 22분 만에 말이죠.

00:27:33.000 --> 00:27:36.560
다음은 Redis의 정말 강력한 기능에 대해서
말씀드리려고 합니다.

00:27:42.840 --> 00:27:44.600
여기 방금 우리가 했던 것과
매우 비슷한 것이 

00:27:44.600 --> 00:27:46.180
있습니다.

00:27:46.180 --> 00:27:47.980
맞습니다. 웹 인터페이스입니다.

00:27:49.340 --> 00:27:53.680
이 IPython notebook 쉘은
실제 제 노트북에서 돌아가고 있습니다.

00:27:55.760 --> 00:27:58.960
그리고 우리가 좀 전에 봤던 것과의 

00:27:58.960 --> 00:28:02.669
유일한 차이점은

00:28:02.669 --> 00:28:10.080
Redis의 환경 설정입니다.

00:28:10.080 --> 00:28:13.260
지금 이 노트북의 Redis 서버는

00:28:13.260 --> 00:28:18.830
라즈베리 파이가 돌아가고 있는 동안
슬레이브 모드로 동작시키려고 합니다.

00:28:18.830 --> 00:28:24.429
이것은 라즈베리 파이의 데이터를 
제 노트북에 복제(replicate)할 것입니다.

00:28:24.429 --> 00:28:26.910
실제 노트북의 하드드라이브에 저장해서

00:28:26.910 --> 00:28:29.960
제 라즈베리 파이의 플래시 카드와 같이 
정보가 날아가지 않게 됩니다.

00:28:29.960 --> 00:28:34.010
이것은 제 라즈베리 파이의 배터리가 다 되더라도 
저는 여전히 가장 최근의 온도 정보에

00:28:34.010 --> 00:28:37.190
접근할 수 있다는 것을 의미합니다.
이건 정말 멋집니다.

00:28:46.700 --> 00:28:49.360
그래서 지금 보시는 것처럼,
우리가 라즈베리 파이를 실행시켰을 때의 결과와 비슷해

00:28:49.360 --> 00:28:50.960
보입니다.

00:28:50.960 --> 00:28:54.720
그리고 우리의 서버에 있는 데이터를 
복제한(replicating) 이후로 

00:28:54.730 --> 00:28:56.470
제가 페이지를 갱신하면

00:28:56.470 --> 00:29:00.360
읽었던 횟수는 증가하고 
온도 정보는 변하는 것을 볼 수 있습니다.

00:29:00.360 --> 00:29:03.720
재밌는 것은 
제 라즈베리 파이가 여기에 있고

00:29:03.720 --> 00:29:09.340
라즈베리 파이에 연결된 랜선을 뽑고 나서
페이지를 갱신하게 되면

00:29:09.340 --> 00:29:13.429
지금 보시는 것처럼
읽은 횟수와 온도의 값은 더는 변하지 않습니다.

00:29:13.429 --> 00:29:15.750
왜냐하면,

00:29:15.750 --> 00:29:18.650
네트워크 연결 없이는 
변경되는 정보를 더 이상 받아서 볼 수 없기 때문입니다.

00:29:19.800 --> 00:29:24.220
재밌는 것은
라즈베리 파이에 다시 랜선을 꽂으면.

00:29:30.300 --> 00:29:32.840
음, 네트워크 연결이 다시 제대로 돼야 

00:29:32.850 --> 00:29:35.050
할 텐데,

00:29:35.050 --> 00:29:36.710
Thank you.

00:29:41.280 --> 00:29:43.680
Disconnected, okay.

00:29:54.380 --> 00:29:56.200
Five minutes.

00:30:03.300 --> 00:30:06.900
제 네트워크 연결이 다시 제대로 되지 않네요.

00:30:06.900 --> 00:30:08.660
[laughter]

00:30:08.660 --> 00:30:15.600
그렇지만 지금까지 진행한 이후에 
네트워크까지 제대로 연결되면

00:30:15.600 --> 00:30:19.440
연결이 끊어진 시간 동안 라즈베리 파이에 
기록된 모든 온도 정보들은

00:30:19.440 --> 00:30:23.240
자동으로 서버에 복제될 것입니다.

00:30:23.240 --> 00:30:26.740
서버로 돌고 있는 제 노트북에 말이죠.

00:30:26.740 --> 00:30:28.330
이건 정말로 강력합니다.

00:30:28.330 --> 00:30:31.210
또 다른 것으로는 물론.
우리는 1개 이상의 라즈베리 파이에 데이터를 복제할 수도 

00:30:31.210 --> 00:30:33.610
있다는 것입니다.

00:30:39.800 --> 00:30:41.800
이게 왜 갑자기 시작했는지 모르겠어요.

00:31:03.100 --> 00:31:06.919
제가 말씀드린 것에서 더 나아가서

00:31:06.919 --> 00:31:09.159
1개 이상의 라즈베리 파이에 데이터를 복제하고
더 많은 센서를 사용해 볼 수 있습니다.

00:31:10.540 --> 00:31:14.360
그래서 다음 버전으로 이렇게 하게 되었습니다.

00:31:14.360 --> 00:31:17.820
마이크로컨트롤러를 이용해서 말이죠.

00:31:17.820 --> 00:31:21.940
이것은 MicroPython을 실행하기 때문에
Python을 실행하는 IoT 장치이기도 

00:31:21.940 --> 00:31:23.909
합니다.

00:31:23.909 --> 00:31:27.530
이것은 가진 기능이 많지 않고,
매우 강력한 프로세서가 탑재된 것도 아니고,

00:31:27.530 --> 00:31:30.809
많은 메모리도 가지고 있지 않습니다.
하지만 이것은 

00:31:30.809 --> 00:31:36.690
내장 무선랜을 가지고 있고 저렴합니다.

00:31:36.690 --> 00:31:40.950
그리고 수명은 라즈베리 파이보다 
10배는 더 깁니다.

00:31:40.950 --> 00:31:45.490
배터리는 라즈베리 파이로 하루 쓸 수 있는 것으로 
1달은 사용할 수 있습니다.

00:31:46.640 --> 00:31:48.440
전력 소모의 차이는 정말 엄청납니다.

00:31:48.440 --> 00:31:50.990
실제 배터리를 사용해서 돌려볼 때 말이죠.

00:31:50.990 --> 00:31:52.770
IoT에서 정말 재미있는 것은.

00:31:52.770 --> 00:31:54.590
왜냐하면, IoT는

00:31:54.590 --> 00:31:56.610
하시다 보면 
트레이드 오프를 자주 마주하게 된다는 점입니다.

00:31:57.960 --> 00:32:00.299
뭘 하시는지에 따라 다르겠지만

00:32:00.299 --> 00:32:02.049
옷을 바느질하려고 할 수도 있습니다.

00:32:02.049 --> 00:32:06.570
그러면 사이즈, 무게, 전력소모 같은 것들이 
중요해지고,

00:32:06.570 --> 00:32:09.410
프로세서가 빠르게 처리해주는 것 또한
중요하게 됩니다.

00:32:12.330 --> 00:32:16.659
그래서 라즈베리 파이 이외의 
다른 옵션들(마이크로컨트롤러)을 확인해보는 것은

00:32:16.659 --> 00:32:18.410
정말 좋은 생각입니다.

00:32:18.410 --> 00:32:23.240
Python을 가지고 IoT를 하는
방법은 정말 많습니다.

00:32:23.240 --> 00:32:26.380
라즈베리 파이는 
이것을 시작하기에 훌륭합니다.

00:32:27.780 --> 00:32:29.600
그래서 조금 더 자세한 정보가 필요한 경우,

00:32:29.600 --> 00:32:33.370
라즈베리 파이나, IoT와 
연동하는 부품들을 파는

00:32:33.370 --> 00:32:36.470
수많은 업체가 있는데,

00:32:36.470 --> 00:32:40.630
거기에 있는 수천 개의 튜토리얼은

00:32:40.630 --> 00:32:43.070
단계별 지침, 그림, 훌륭한 아이디어를
가지고 있습니다.

00:32:45.580 --> 00:32:48.320
이것은 여러분에게 영감을 줄 수도 있습니다.
그리고 놀라운 것들을 직접 해볼 수 있습니다.

00:32:48.330 --> 00:32:50.220
IoT를 이용해서요.

00:32:50.220 --> 00:32:52.340
이것을 가지고
여러분은 거의 모든 것을 다 해볼 수 있습니다.

00:32:53.540 --> 00:32:56.920
물론 마이크로컨트롤용 Python인 경우

00:32:56.929 --> 00:32:59.249
이것은 또 완전히 다른 영역으로 넘어갑니다.

00:32:59.960 --> 00:33:03.040
인제 그만 마치려고 합니다.
Open space 시간을

00:33:03.040 --> 00:33:06.090
4시까지 가질 예정입니다.
만약 질문이 있으시거나

00:33:06.090 --> 00:33:10.750
좀 더 자세히 알고 싶으신 분은
편하게 저를 찾아와 주세요.

00:33:10.750 --> 00:33:12.580
아마도,
저는 여기에서 

00:33:12.580 --> 00:33:14.440
스프린트도 할 예정입니다.

00:33:14.450 --> 00:33:17.760
마지막으로 질문할 시간이 있는지 잘 모르겠습니다.

00:33:17.760 --> 00:33:21.820
제 생각에 거의 끝났다고 생각이 듭니다.
시간 내주셔서 감사합니다.

00:33:21.830 --> 00:33:25.640
저는 여러분들이 제가 Python을 가지고 IoT를
한 것을 보시고 영감을 얻어 가셨으면

00:33:25.640 --> 00:33:28.300
좋겠습니다.

00:33:28.300 --> 00:33:35.480
[applause]

00:33:35.480 --> 00:33:38.280
(moderator)
질문 1~2개 정도 받을 시간이 있습니다.

00:33:45.680 --> 00:33:48.000
(audience member 1)
질문 있습니다.

00:33:48.000 --> 00:33:51.280
[inaudible question]

