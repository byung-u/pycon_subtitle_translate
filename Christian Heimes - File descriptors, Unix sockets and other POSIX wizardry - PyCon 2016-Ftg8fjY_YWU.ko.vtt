WEBVTT
Kind: captions
Language: ko

00:00:57.180 --> 00:01:01.980
이상하네요, 오, 됐다.

00:01:08.020 --> 00:01:10.540
PyCon 2016의 첫 번째 발표에 오신 것을 

00:01:10.549 --> 00:01:12.820
환영합니다.

00:01:12.820 --> 00:01:16.180
첫 번째 세션에서는,
Christian Heimes가 발표합니다.

00:01:16.180 --> 00:01:21.520
Christian Heimes는 
CPython과 Red Hat에서 오랫동안
핵심 개발자로 활동해 왔습니다.

00:01:21.520 --> 00:01:23.620
오늘 발표에서 말씀해주실 내용은
file descriptors와

00:01:23.620 --> 00:01:26.100
Unix sockets 및 기타 POSIX magic입니다.

00:01:26.100 --> 00:01:28.580
자 그럼, 따뜻한 환영 부탁드립니다.

00:01:28.580 --> 00:01:34.540
[applause]

00:01:35.340 --> 00:01:37.340
예, 안녕하세요.

00:01:37.340 --> 00:01:40.420
PyCon에 오신 것과
제 발표에 오신 것을 환영합니다.

00:01:40.420 --> 00:01:43.040
영어로 발표하는 것은 처음입니다.

00:01:43.049 --> 00:01:45.049
이런 대중 앞에서는 말이죠.

00:01:45.049 --> 00:01:48.269
그래서, 제 영어가 다소 완벽하지 못하더라도
양해해주시기 바랍니다.

00:01:48.269 --> 00:01:50.800
그럼, 시작해 보겠습니다.

00:01:50.800 --> 00:01:53.460
저는 레드햇에서 1년 넘게 일하고 있습니다. 

00:01:53.460 --> 00:01:59.560
보안 및 아이덴티티 관리(IAM)부서의 
선임 소프트웨어 엔지니어로 근무하고 있습니다.

00:01:59.560 --> 00:02:04.180
저희는 컴퓨터를 보다 보안에 안전하게 하도록
소프트웨어를 개발하고 있습니다.

00:02:04.180 --> 00:02:07.800
그리고 그 중 하나로
저는 최근에 연구하고 있습니다.

00:02:07.800 --> 00:02:09.880
Custodia라고 부르고 있습니다.

00:02:09.880 --> 00:02:13.720
암호와 키 같은 감춰진 것들을 
가져올 수 있는 일종의 컨테이너이고,

00:02:13.720 --> 00:02:17.360
보안을 더욱 강하게 할 수 있습니다.

00:02:17.360 --> 00:02:21.680
그리고 이 발표에서 실제로 많은 것들에 대해서
설명해 드릴 예정입니다.

00:02:21.690 --> 00:02:23.950
25분 동안에요.

00:02:25.500 --> 00:02:27.540
안타깝지만 저에게는 25분밖에 없어서,

00:02:27.540 --> 00:02:30.900
바로 사용할 수 있는 레시피들을
알려드릴 수는 없습니다.

00:02:30.910 --> 00:02:33.480
그래서 저는 몇 가지 개념에 대해서 
소개하려고 합니다.

00:02:33.480 --> 00:02:36.400
그리고 여러분의 애플리케이션에서 
사용할 수 있는 몇 가지 도구들에 대해서도 
소개할 예정입니다.

00:02:36.400 --> 00:02:40.740
제가 설명하려는 대부분은
리눅스에 중점을 두고 있습니다.

00:02:40.740 --> 00:02:45.000
그리고 유닉스계열의 운영 체제에서만 작동합니다.
그래서, POSIX입니다.

00:02:45.000 --> 00:02:47.820
그리고 모든 예제는 python3로 구현했습니다.

00:02:47.820 --> 00:02:50.700
예, 아무도 python2를 더는 사용하지 않겠죠,
아마도(그랬으면 좋겠어요).

00:02:50.700 --> 00:02:52.740
[청중 웃음소리]

00:02:52.740 --> 00:02:58.040
그래서 오늘의 의제로 :
저는 FD를 설명할 것입니다.

00:02:58.050 --> 00:03:01.020
그리고 나중에 
약간의 운영 체제 관련 내용과

00:03:01.020 --> 00:03:04.120
Linux 코드에 관해서도 설명하려 합니다.

00:03:04.120 --> 00:03:09.600
다음으로는 FD가 프로세스들과
어떻게 상호작용을 하는지에 대해서,

00:03:09.600 --> 00:03:11.600
그리고 약간의 네트워킹 관련 설명,

00:03:11.600 --> 00:03:15.240
그리고 마지막으로 유닉스 소켓, 컨테이너, 샌드박스에 대해서
설명하려 합니다.

00:03:15.240 --> 00:03:18.340
그리고 제가 오늘 얼마나 빨리 말을 하느냐에 따라

00:03:18.340 --> 00:03:20.600
(시간이 남은 경우를 대비해)
보너스 트랙도 조금 준비해왔습니다.

00:03:21.360 --> 00:03:23.480
그러다 보니, 단순하게 해야 했습니다.

00:03:23.480 --> 00:03:26.800
죄송하지만, 저는 발표의 몇 군데에서는
거짓말을 했습니다.

00:03:26.800 --> 00:03:29.470
그리고 모든 세부사항에 대해 깊이 말씀드릴 수 있는
시간이 없어서

00:03:29.470 --> 00:03:32.520
발표의 일부 내용은 건너뛰게 될 것입니다.

00:03:32.520 --> 00:03:34.540
더 많은 것을 알고 싶으시다면,

00:03:34.540 --> 00:03:38.200
오늘 4시부터 Open Space 시간을 가질 예정입니다.
(거기에 오시면 됩니다.)

00:03:39.960 --> 00:03:41.900
File descriptors (파일 기술자)

00:03:41.900 --> 00:03:45.940
아마도 여러분은 유닉스에서 그 용어를 들었을 것입니다.
"모든 것이 파일(everything is a file)”

00:03:45.950 --> 00:03:50.400
디폴트 시스템, prog 파일 시스템 같은 것에서요.

00:03:50.400 --> 00:03:52.400
여러분은 FD를 하드웨어와 상호작용하기 위해 사용할 수도 있고,

00:03:52.400 --> 00:03:57.200
프로세스, 네트워킹, 설정 등의 정보를 얻기 위해 
사용할 수도 있습니다.

00:03:58.120 --> 00:04:02.020
그리고 모든 것을 FD를 가지고 합니다.
입력/출력을 할 때마다 말이죠.

00:04:02.020 --> 00:04:06.300
어떤 것을 읽고, 쓰고, 
심지어는 리소스와 상호작용을 하는 데에

00:04:06.300 --> 00:04:08.580
여러분은 FD를 사용합니다.

00:04:10.340 --> 00:04:12.680
FD는 파일을 읽고 쓰는 모든 것에 사용합니다.

00:04:12.680 --> 00:04:16.780
심지어는 디렉터리를 읽고 쓸 때도요.

00:04:16.790 --> 00:04:21.480
하드웨어를 제어할 수가 있고,
IPC 통신을 할 수도 있습니다.

00:04:21.480 --> 00:04:26.140
프로세스 간에 일종의 대화라고 보시면 됩니다.
또한, 네트워킹, I/O 멀티플렉싱,

00:04:26.140 --> 00:04:30.740
비동기 I/O의 핵심.
파일 시스템 모니터링,

00:04:30.740 --> 00:04:33.060
그리고 더 많은 것이 있습니다.

00:04:33.060 --> 00:04:36.720
FD는 커널 내부의 티켓으로 생각하셔도 됩니다.

00:04:36.720 --> 00:04:38.740
그래서 커널에 가서,

00:04:38.750 --> 00:04:42.010
자원에 접근하기 위해 커널에 요청합니다.

00:04:42.010 --> 00:04:43.870
티켓을 받고,

00:04:43.870 --> 00:04:45.640
FD로 뭔가를 하고 싶을 때마다

00:04:45.640 --> 00:04:47.620
이 자원(FD)을 가지고

00:04:47.629 --> 00:04:50.130
커널에게 다시 보여주면 됩니다.
아까 그 FD의 번호 (티켓 같은).

00:04:50.130 --> 00:04:55.850
그러면 커널은 뭔가를 수행하게 됩니다.

00:04:55.850 --> 00:04:59.290
몇 개의 정해진 숫자들이 있습니다.
0, 1, 2

00:04:59.290 --> 00:05:03.210
표준 입력(0), 출력(1), 에러 출력(2)

00:05:03.210 --> 00:05:07.650
또한 숫자 1은 에러를 가리키기도 합니다.

00:05:07.650 --> 00:05:09.630
Python에서는 그렇지 않습니다.

00:05:09.630 --> 00:05:12.880
Python 예외처리를 해줍니다. 
그래서 여러분 같은 개발자들은

00:05:12.880 --> 00:05:16.520
Python에서 -1을 고려해주어야 합니다.
no.

00:05:17.560 --> 00:05:20.640
아마 보신 적이 있을 듯한 
아주 간단한 예제가 여기 있습니다.

00:05:20.640 --> 00:05:24.760
“with"문으로 파일을 열고,
파일에서 읽은 다음 그 내용을 출력해줍니다.

00:05:24.760 --> 00:05:29.640
이 예제에서는 이미 2개의 FD를 사용합니다.

00:05:29.640 --> 00:05:31.600
프로세스가 실행되면

00:05:31.600 --> 00:05:35.460
파일에서 읽습니다.
"open"은 FD를 생성하고,

00:05:35.460 --> 00:05:38.340
“print”는 다른 FD에 씁니다.

00:05:38.340 --> 00:05:41.620
그것은 shell에 전송됩니다.

00:05:42.940 --> 00:05:45.460
FD에 대한 아주 간단한 예입니다.

00:05:45.460 --> 00:05:48.139
FD를 가지고 더 많은 것들을
해볼 수 있습니다.

00:05:48.139 --> 00:05:53.019
이미 열려있는 파일을 참조하여 
실제 그 FD를 사용할 수도 있습니다.

00:05:53.020 --> 00:05:55.040
어떤 경우에는 유용합니다.

00:05:55.040 --> 00:05:57.400
그러나 또한, 보안에 영향을 미칩니다.

00:05:57.400 --> 00:05:59.480
보통은 더 안전합니다.

00:05:59.480 --> 00:06:01.400
이미 파일이 열려 있다면,

00:06:01.400 --> 00:06:03.420
파일의 상태 정보를 얻을 수 있습니다.

00:06:03.420 --> 00:06:06.740
파일의 권한 설정을 바꿀 수도 있습니다.
(Sticky bit 설정: 0o640)

00:06:07.860 --> 00:06:10.600
몇 년 전,

00:06:10.600 --> 00:06:13.819
Python은 dir(디렉터리) FD를 사용할 수 있었습니다.

00:06:13.819 --> 00:06:19.219
FD를 경로 표시기(location indicator) 
같은 디렉터리에 사용할 수 있습니다.

00:06:20.540 --> 00:06:22.980
그것들은 python에서 더 많이 사용합니다.

00:06:22.980 --> 00:06:27.999
Python, 음 아마도 3.4에서 
관련 기능을 소개했던 것 같습니다.

00:06:29.680 --> 00:06:33.820
그리고 FD로 하드웨어를 제어할 수도 있습니다.

00:06:33.820 --> 00:06:38.080
그리고 이것이 저의 오늘 발표에서 
유일한 데모입니다.
그리고 제대로 동작했으면 좋겠어요.

00:06:42.760 --> 00:06:44.260
[clicking sound]

00:06:44.260 --> 00:06:46.840
들으셨나요?

00:06:46.840 --> 00:06:50.760
청력이 약하신 분들을 위한 
자막은 없습니다.

00:06:50.760 --> 00:06:54.879
음, 오, 안 되겠어요.

00:06:55.680 --> 00:06:57.860
숨겨야겠네요.

00:06:58.540 --> 00:07:00.520
바로 이거였어요.

00:07:00.520 --> 00:07:02.560
[laughter]

00:07:03.500 --> 00:07:05.540
미리 녹화해둔 거예요.

00:07:05.540 --> 00:07:07.660
사실 저는 FD를 사용했습니다.

00:07:07.660 --> 00:07:11.040

to open some hardware device,
하드웨어 장치를 열기 위해서 
dev/cdrom을 사용했습니다.

00:07:11.040 --> 00:07:16.100
그리고 명령어를 내려서 CD-ROM을 꺼냈고
다시 집어넣었습니다.

00:07:18.500 --> 00:07:20.560
이것은 리눅스 베이에서만 작동합니다.

00:07:20.560 --> 00:07:22.560
모든 운영 체제는

00:07:22.560 --> 00:07:25.160
하드웨어를 제어하기 위한
그것들만의 매직코드 라인을 가지고 있습니다.

00:07:25.160 --> 00:07:27.640
Operating System 101.

00:07:27.640 --> 00:07:31.320
다른 몇몇 트릭을 알려드리기 전에 

00:07:31.320 --> 00:07:35.320
운영 체제가 내부적으로 
어떻게 작동하는지 설명해야 합니다.

00:07:35.320 --> 00:07:38.280
Dark Ages(어둠의 시기)가 있었습니다.

00:07:38.280 --> 00:07:41.920
프로세스 간에 아무런 격리가 없었습니다.

00:07:41.920 --> 00:07:46.580
하드웨어에서건, 소프트웨어에서건
아무나 읽고 쓸 수 있었습니다.

00:07:46.580 --> 00:07:52.220
그래서 1개의 프로그램이 충돌 나면
전체 시스템을 뻗어버리게 했었습니다.

00:07:52.220 --> 00:07:56.760
저와 같은 시기 혹은 훨씬 이전의 컴퓨터로 
DOS를 사용했었다면

00:07:56.760 --> 00:07:59.740
1개의 프로그램 충돌은 대개
컴퓨터를 다시 시작해야 하는 것을 의미했었습니다.

00:08:00.469 --> 00:08:02.709
최신 운영 체제에서는,

00:08:02.709 --> 00:08:05.860
하드웨어와 소프트웨어 간에 
레이아웃을 가지고 있습니다.

00:08:05.860 --> 00:08:07.860
그것을 커널이라고 부릅니다.

00:08:07.860 --> 00:08:11.180
커널은 많은 작업을 수행합니다.

00:08:11.189 --> 00:08:14.580
저는 모든 하드웨어 드라이버에 대해서 
설명하지는 않을 것입니다.

00:08:14.580 --> 00:08:18.760
커널은 하드웨어와 더 쉽게 대화(제어)
할 수 있게 해줍니다.

00:08:18.760 --> 00:08:22.139
그보다는,
커널은 매우 중요한 단계(step)입니다.

00:08:22.139 --> 00:08:24.199
프로세스를 격리하는

00:08:24.200 --> 00:08:27.500
그래서 프로세스는 직접 다른 프로세스와 
상호작용을 할 수 없습니다.

00:08:27.509 --> 00:08:30.740
대신 커널을 사용하는 방법이 있습니다.

00:08:30.740 --> 00:08:33.260
적어도 1가지 방법으로 
통신 채널을 설정하는 방법으로요.

00:08:33.260 --> 00:08:37.600
커널은 또한 보안에 관한 수많은 검사를 합니다.

00:08:37.600 --> 00:08:39.660
자, 여러분이 파일 사용 권한이 있다고 가정해봅시다.

00:08:39.660 --> 00:08:41.780
여러분은 여러분의 시스템에
사용자와 그룹을 가지고 있습니다.

00:08:41.780 --> 00:08:44.120
네트워킹의 경우,
아마도 방화벽,

00:08:44.120 --> 00:08:47.620
그리고 여러분의 컴퓨터에 
물리적인 메모리를 가지고 있습니다.

00:08:47.630 --> 00:08:49.730
그리고 프로세스에서는 
가상 메모리를 가지고 있습니다.

00:08:49.730 --> 00:08:54.280
그리고 커널이 가상 메모리를
실제 물리적인 메모리에 매핑하는 것에 대해

00:08:54.290 --> 00:08:58.110
말씀드리고 싶습니다.
그러나 안타깝게도, 오늘은 불가능합니다.

00:08:58.110 --> 00:09:00.450
25분은 매우 짧습니다.

00:09:02.360 --> 00:09:06.420
그래서, 그것을 요약하면,
여러분이 뭔가를 하려고 할 때마다,

00:09:06.420 --> 00:09:09.700
만약 여러분이 읽거나 쓰기 작업을 하는 경우
커널에 요청(talk)해야 합니다.

00:09:10.780 --> 00:09:13.880
커널에 요청(talk)하는 방식을 
syscall이라고 합니다.

00:09:13.880 --> 00:09:18.900
시스템 호출 - 그것은 작업간 전환하는 하나의 방법입니다.

00:09:18.910 --> 00:09:23.050
사용자 영역(user-space) 프로그램에서
커널 영역(kernel-space) 프로그램으로요.

00:09:23.050 --> 00:09:26.380
아마도 여러분께서는 “context switch”라는
용어를 들어 보셨을 것입니다.
(context switching : 자신의 현 상태를 잃지 않은 채 
한 프로그램에서 다른 프로그램으로 전환할 수 있게 해주는 것, 텀즈)

00:09:26.380 --> 00:09:28.440
컨텍스트 스위치는 다소 느립니다.

00:09:28.440 --> 00:09:30.440
CPU의 수백 사이클을

00:09:30.440 --> 00:09:32.780
사용해서입니다. 요즘 시스템에서요.

00:09:32.780 --> 00:09:38.180
그리고 그것들을 많이 사용하면, 
요즘엔 거의 400 사이클 정도 됩니다.

00:09:38.180 --> 00:09:42.180
그리고 간단한 예제로 다시 돌아가 보겠습니다.
방금 파일을 연 곳에서,

00:09:42.180 --> 00:09:45.300
파일로부터 읽어 들이고, 출력했습니다.

00:09:47.140 --> 00:09:49.400
일반적으로 systrace or strace라고 부르는 유틸입니다.

00:09:49.400 --> 00:09:55.500
프로그램이 어떤 종류의 시스템 콜을 하고 있는지 
볼 수 있습니다.

00:09:55.510 --> 00:10:00.520
그래서 이 예제에서는 
“with”문으로 파일을 열었습니다.

00:10:00.520 --> 00:10:02.540
그리고 이때의 FD 번호는 3번입니다.

00:10:02.540 --> 00:10:05.700
커널은 일반적으로 열려있는 FD의 다음 번호를
가져갑니다.

00:10:05.700 --> 00:10:08.460
그리고 python에서는 

00:10:08.460 --> 00:10:10.950
실제 파일이 맞는지를 확인하는 몇 가지 작업을 합니다.

00:10:10.950 --> 00:10:15.430
디렉터리를 여는 것을 막기 위해서요.

00:10:15.430 --> 00:10:19.740
무언가가 있는 경우 파일의 첫 번째 위치로 이동합니다. —

00:10:19.740 --> 00:10:21.560
음, 왜 그런지 정말로 모르겠어요.

00:10:21.560 --> 00:10:23.360
아마도 Benjamin은 알고 있을 거예요.

00:10:23.360 --> 00:10:25.120
그가 만들었거든요.

00:10:25.120 --> 00:10:26.920
[chuckles(웃음)]

00:10:26.920 --> 00:10:32.960
그런 다음 FD 번호 3을 사용하여
몇 개를 더 읽고 또 읽습니다.

00:10:32.970 --> 00:10:34.530
마지막의 숫자 ‘=19’는

00:10:34.530 --> 00:10:39.860
example.txt 파일에서 19글자를 읽어 들인 것을
의미합니다.

00:10:39.860 --> 00:10:41.620
그리고 다시 시도합니다.

00:10:41.620 --> 00:10:43.400
네, 파일은 비어 있습니다.

00:10:43.400 --> 00:10:46.340
그리고 python은 다른 FD 번호 1을 사용합니다.

00:10:46.340 --> 00:10:53.040
이게 핵심입니다.
실제로 문자열을 쉘에 씁니다. (화면에 출력해줍니다)

00:10:53.040 --> 00:10:56.040
그리고 마지막으로 FD를 가지고 있는 경우 (open한 경우)

00:10:56.040 --> 00:10:58.000
반드시 FD를 닫아 주어야 합니다. (close(FD))

00:10:58.000 --> 00:11:00.740
왜냐하면 FD는 실제로 많지 않은 자원이기 때문입니다.

00:11:00.740 --> 00:11:02.740
그래서 보통은 FD 자원을 낭비하지 않으려 합니다.

00:11:02.740 --> 00:11:07.240
만약 오랫동안 실행하는 프로그램을 가지고 있고,
FD를 다 사용해버리면
(이 시스템에 FD의 leak이 발생하는 등)

00:11:07.240 --> 00:11:09.340
예, 더는 (해당 시스템에서) 아무것도 할 수 없게 됩니다.

00:11:10.780 --> 00:11:15.180
그리고 커널은 몇 가지 테이블과 정보를 내부적으로 관리합니다.

00:11:15.190 --> 00:11:17.780
시스템에서는 global하게 열려있는 파일에 대한
테이블을 가지고 있습니다.

00:11:17.780 --> 00:11:19.710
이것은 커널에 하나의 거대한 테이블입니다.

00:11:19.710 --> 00:11:22.430
모든 열려있는(open된) 자원 정보를 가지고 있습니다.

00:11:23.340 --> 00:11:26.600
모든 프로세스는 FD 자체가

00:11:26.600 --> 00:11:28.460
테이블 자체를 참조합니다.

00:11:28.460 --> 00:11:30.240
프로세스의 FD 테이블은 

00:11:30.240 --> 00:11:32.040
실제로는 매우 작습니다.

00:11:32.040 --> 00:11:34.400
이것은 단지 커널의 일부 숫자들만 매핑합니다.

00:11:36.600 --> 00:11:38.660
그래서, 몇 가지 예입니다.

00:11:38.660 --> 00:11:40.660
파일을 열면, FD 번호를 가지게 됩니다.

00:11:40.660 --> 00:11:43.020
그리고 이것은 global 테이블의 엔트리를 가리키며,

00:11:43.020 --> 00:11:46.300
마지막에는 파일에서 끝이 납니다.

00:11:46.310 --> 00:11:48.570
같은 파일을 다시 열 수 있습니다.

00:11:48.570 --> 00:11:50.860
그리고 다른 FD 번호를 가집니다.

00:11:50.860 --> 00:11:53.620
여러분은 또한 FD를 복제할 수도 있습니다.

00:11:53.630 --> 00:11:56.810
그리고 아마도 복제해서 얻은 FD는 
동일한 엔트리를 가리키고 있을 것입니다.

00:11:58.920 --> 00:12:01.920
그리고 또 다른 유용한 작업이 있습니다.

00:12:01.920 --> 00:12:03.920
그것은 나중에 보시게 될 것입니다.

00:12:03.920 --> 00:12:09.400
FD는 덮어쓰고, 이름을 바꿀 수도 있습니다.

00:12:09.400 --> 00:12:11.940
마지막으로 프로세스를 알 수 있는

00:12:11.940 --> 00:12:14.220
FD를 얻는 방법이 있습니다.

00:12:14.220 --> 00:12:19.060
그리고 갑자기 다른 프로세스가 동일한 
전역 엔트리를 사용하게 됩니다.

00:12:20.540 --> 00:12:26.680
이 테이블에서 FD 테이블 자체는

00:12:26.690 --> 00:12:28.630
이 매핑을 포함합니다.

00:12:28.630 --> 00:12:30.610
다른 플래그로는,
Close-exec or cloexec가 있습니다.

00:12:30.610 --> 00:12:33.680
몇 분 동안 설명해 드리려고 합니다.

00:12:33.690 --> 00:12:38.850
Open 파일 테이블에는 실제 상태 정보가 있습니다.

00:12:38.850 --> 00:12:40.870
파일의 path,

00:12:40.870 --> 00:12:44.420
모드, 
파일을 열고 있는지,
읽기, 쓰기 모드인지, 둘 다인지,

00:12:44.420 --> 00:12:46.460
파일의 소유자는 누구인지,
lock이 걸린 상태인지,

00:12:46.460 --> 00:12:49.840
자격증명(credentials), 
참조 횟수(reference count) 등등

00:12:49.840 --> 00:12:53.760
따라서 열린 파일 테이블의 엔트리인
전역 테이블은

00:12:53.760 --> 00:12:56.140
이 오래된 장치와 조금 비슷합니다.

00:12:56.140 --> 00:12:58.160
전역 카운터가 있다고 가정해 보겠습니다.

00:12:58.160 --> 00:13:03.400
그러면 만약 동일한 리소스로부터 읽어 들이는
여러 프로그램이 있는 경우,

00:13:03.400 --> 00:13:05.620
독립적으로 실행할 수는 없습니다.

00:13:05.620 --> 00:13:09.180
다음은,
유닉스가 어떻게 프로세스를 생성하는지에 대해서
말씀드리겠습니다.

00:13:09.180 --> 00:13:13.500
익숙하지 않은 사람들에게는 조금 이상합니다.

00:13:13.500 --> 00:13:19.120
새로운 프로세스를 만드는데
실제로 두 단계가 있습니다.

00:13:19.120 --> 00:13:21.180
하나는 포크가 있습니다.

00:13:21.180 --> 00:13:23.500
포크는 현재 프로세스의 클론을 만듭니다.

00:13:23.510 --> 00:13:28.770
그리고 이것은 쓰레딩을 제외한 거의 완벽한 
복사본입니다.

00:13:28.770 --> 00:13:31.100
그리고 이 child 프로세스는

00:13:31.110 --> 00:13:34.820
parent 프로세스로부터 FD 테이블을 상속받습니다.

00:13:34.820 --> 00:13:39.460
그래서 실제로 동일한 전역 엔트리를 가리킵니다.

00:13:39.460 --> 00:13:44.800
그리고 2번째 여러분이 해보실 수 있는 것은,
oh no, sorry
첫 번째 예시입니다.

00:13:44.800 --> 00:13:51.060
포크를 실행한 다음 첫 번째 프로세스를 실행하면, 

00:13:51.060 --> 00:13:56.060
그 프로세스는 현재 부모 프로세스입니다.

00:13:56.060 --> 00:14:00.680
이것은 부모 프로세스의 
부모 중 첫 번째에서 발생했었습니다.

00:14:00.680 --> 00:14:06.000
example.txt를 python으로 읽어 들이는 작업이요.

00:14:06.000 --> 00:14:10.140
그리고 거의 동시에,
자식 프로세스도 읽어 들입니다.

00:14:10.140 --> 00:14:14.010
같은 FD로부터요.
그리고 전역 테이블의

00:14:14.010 --> 00:14:16.470
끝까지 읽어 들입니다.

00:14:17.260 --> 00:14:19.500
2번째 단계는

00:14:19.510 --> 00:14:22.550
단순히 프로세스를 포크하여 복사본을 얻는 것인데
별로 유용하지는 않습니다.

00:14:22.550 --> 00:14:24.610
만약 다른 프로그램으로 동작시키고 싶은 경우에는

00:14:24.610 --> 00:14:27.440
이 2번째 단계에서
현재의 코드를 

00:14:27.440 --> 00:14:30.340
다른 코드로 바꿔줍니다.
그리고 그것을 exec라고 합니다.

00:14:31.980 --> 00:14:34.640
exec 하는 경우에도,
모든 FD 정보를 가져옵니다.

00:14:34.640 --> 00:14:36.640
원래 프로세스에서

00:14:36.640 --> 00:14:38.680
이는 보안 문제를 야기할 수 있습니다.

00:14:38.680 --> 00:14:40.660
그 부분이 바로 cloexec이 들어오는 곳이기 때문입니다.

00:14:40.660 --> 00:14:44.180
그래서 모든 cloexec로 마킹했던 FD는
마지막에는 close 해야 합니다.

00:14:44.180 --> 00:14:46.560
Victor Stinner 덕분에 python에서는

00:14:46.560 --> 00:14:49.840
close하는 것에 대해서 신경 쓸 필요가 없습니다.

00:14:49.840 --> 00:14:51.860
그럼, 빠른 요약.

00:14:51.860 --> 00:14:54.040
당신이 무언가를 할 때마다,
커널에 가면,

00:14:54.040 --> 00:14:57.800
여러 다른 종류의 테이블을 가지고 있습니다.

00:14:57.800 --> 00:15:00.760
그리고 fork & exec에 의해서 
새로운 프로세스가 생성됩니다.

00:15:02.090 --> 00:15:04.940
이제 왜 이것이 유용한지
여러분은 궁금해하실 것입니다.

00:15:04.940 --> 00:15:07.800
자식 프로세스는 실제로
부모 프로세스와 같은 FD를

00:15:07.800 --> 00:15:10.060
가집니다.

00:15:10.060 --> 00:15:12.540
Python에는 subprocess.PIPE 같은 것이 있습니다.

00:15:12.540 --> 00:15:15.840
또는,
파이핑이 쉘 안으로 들어옵니다. 
(ls | wc -l)

00:15:15.840 --> 00:15:18.780
파이프는 실제로 실제 수도관이라고 생각하셔도 됩니다.

00:15:21.060 --> 00:15:24.400
한쪽 끝에서는 데이터가 들어오고

00:15:24.410 --> 00:15:26.940
다른 한쪽 끝에서는 데이터가 나갑니다.

00:15:26.940 --> 00:15:29.920
이것은 일반적인 파이프입니다.

00:15:29.920 --> 00:15:36.520
이 파이프의 동작 방식은
os.pipe와 많은 공통점이 있습니다.

00:15:36.520 --> 00:15:38.540
Python의 표준 라이브러리는 매우 좋습니다.

00:15:38.540 --> 00:15:40.540
2개의 파이프 끝의 정보를 얻기에는 말이죠.

00:15:40.540 --> 00:15:45.380
서브 프로세스가 새로운 프로세스를 생성하면

00:15:45.380 --> 00:15:49.560
우선 그 프로세스 자신을 포크합니다.
그러고 나서 체크를 합니다.

00:15:49.560 --> 00:15:51.360
아, 부모 프로세스입니다.

00:15:51.360 --> 00:15:53.360
부모 프로세스에서 write FD는 
불필요해서

00:15:53.360 --> 00:15:55.740
close 하여 없앱니다.

00:15:56.460 --> 00:15:59.960
그리고 자식 프로세스에서는 read FD가 
불필요해서 close 합니다.

00:15:59.960 --> 00:16:03.580
자식 프로세스가 같은 쪽 끝을 닫아서
엉망으로 만들어 버리면 안 되기 때문입니다.

00:16:03.580 --> 00:16:05.580
그런 다음 2단계를 사용합니다.

00:16:05.580 --> 00:16:08.100
그것이 FD를 1로 rename 합니다.

00:16:08.100 --> 00:16:12.060
마지막으로 ls와 같은 프로그램을 실행합니다.

00:16:13.180 --> 00:16:15.760
그런 다음 부모 프로세스는

00:16:15.760 --> 00:16:17.800
FD로부터 다시 읽을 수 있습니다.

00:16:17.800 --> 00:16:21.240
이것이 서브 프로세스에서
파이프가 작동하는 방식입니다.

00:16:22.120 --> 00:16:24.160
하지만 물론,
프로세스 간의 통신은

00:16:24.160 --> 00:16:26.100
크게 흥미롭지 않습니다.

00:16:26.100 --> 00:16:29.340
아마도 다른 컴퓨터와 글로벌하게 통신하는 것을 
더 관심 있어 할지도 모르겠습니다.

00:16:29.340 --> 00:16:31.720
그래서 이번에는 네트워크 소켓입니다.

00:16:31.720 --> 00:16:35.840
네트워크 소켓은 택배 배달 시스템과 비슷합니다.

00:16:35.840 --> 00:16:39.880
분류하는 물류 센터에서 몇 번의 과정을 거쳐서
패키지를 보냅니다.

00:16:39.890 --> 00:16:42.300
여기서 라우팅 및 주소가 지정됩니다.

00:16:42.300 --> 00:16:46.420
그래서 패키지를 보내려면
누군가에게

00:16:46.420 --> 00:16:48.420
배송지 주소를 알아야 합니다.

00:16:48.420 --> 00:16:50.360
그리고 패키지를 보냈던 다른 사람은

00:16:50.360 --> 00:16:54.350
물론 누구에게 응답해야 할지 알 필요가 있습니다.

00:16:54.350 --> 00:16:56.830
글자 그대로

00:16:56.830 --> 00:17:03.020
이러한 주소 지정 및 라우팅은
IPv4, IPv6를 사용합니다.

00:17:03.030 --> 00:17:06.850
그래서 이 기본적인 인터넷 프로토콜에 대해서는
여러분 대부분은 아마 들어보셨을 것입니다.

00:17:06.850 --> 00:17:11.079
두 번째로 flow 제어하는 기능도 있습니다.

00:17:11.079 --> 00:17:14.339
이것은 마치,
여러분은 패키지를 단순히 보내고 싶으십니까?

00:17:14.339 --> 00:17:16.730
아니면 패키지를 전송한 후

00:17:16.730 --> 00:17:19.169
그 패키지가 상대방에게 전송되었다는

00:17:19.169 --> 00:17:22.949
영수증까지 받고 싶으십니까?

00:17:22.949 --> 00:17:25.109
그것이 바로 TCP와 UDP입니다.

00:17:25.780 --> 00:17:28.540
그럼, 빠른 예.

00:17:28.549 --> 00:17:31.710
이것은 우리의 유닉스 서버입니다.

00:17:31.710 --> 00:17:33.740
소켓 서버죠.

00:17:33.740 --> 00:17:35.740
그래서 port와 ip 주소를 바인딩하면

00:17:35.749 --> 00:17:38.480
건물 주소나 아파트 주소 같은 주소가 됩니다.

00:17:38.480 --> 00:17:40.600
그리고 listen하며
패키지(패킷)를 기다립니다.

00:17:40.600 --> 00:17:42.799
그리고 마침내 패키지를 accept 합니다.

00:17:42.799 --> 00:17:49.019
서버는 내부적으로 연결하기 위한

00:17:49.020 --> 00:17:51.260
소켓 FD를 만들고

00:17:51.260 --> 00:17:55.460
클라이언트에서도 마찬가지로
소켓 FD를 만듭니다.

00:17:55.470 --> 00:17:58.970
그리고 연결한 후에 상대 서버에 전송합니다.

00:17:58.970 --> 00:18:02.640
아마 여기 계신 모든 분께서 
알지 못하셨던 내용일 수도 있습니다.

00:18:02.640 --> 00:18:07.180
IPv4와 IPv6는 호환되지 않습니다.

00:18:07.180 --> 00:18:10.360
그래서 서로 다른 주소처럼 사용해야 합니다.

00:18:10.360 --> 00:18:14.880
그리고 다른 종류의 주소 이름을 사용합니다.

00:18:17.080 --> 00:18:20.600
이제 약속드렸던 유닉스 소켓입니다.

00:18:20.600 --> 00:18:28.220
유닉스 소켓은 파이프와 네트워크 연결을 
섞은 것과 비슷합니다.

00:18:28.220 --> 00:18:31.040
그래서 유닉스 소켓은 네트워크 연결을 할 수
없습니다.

00:18:31.040 --> 00:18:33.940
리미터이기 때문에 현재 컴퓨터에서만 
작동합니다.

00:18:33.940 --> 00:18:38.940
유닉스 소켓은 옛날의 에어슈터 전송 시스템과 
비슷합니다.

00:18:38.940 --> 00:18:42.080
건물에서 파이프를 이용해서 전송했던 방식

00:18:42.080 --> 00:18:46.360
예를 들었던 건물과 마찬가지로
OS에서

00:18:46.370 --> 00:18:49.670
프로세스와 같은 다른 것들이 서로 통신하는 방식도
비슷합니다.

00:18:49.670 --> 00:18:51.840
모든 것이 내부에(in house) 
있기 때문에 가능합니다.

00:18:51.850 --> 00:18:57.249
하나의 커널 내부에,
추가 기능과

00:18:57.249 --> 00:19:00.029
보안 관련 추가 설정이 있습니다.

00:19:00.029 --> 00:19:04.279
그리고 커널은 이들 파이프들이 

00:19:04.279 --> 00:19:07.179
다른 것들로부터 공격받지 않도록
보호해줍니다.

00:19:08.720 --> 00:19:13.160
메시지를 보내기 위한
멋진 캡슐 라인이 있습니다.

00:19:13.160 --> 00:19:15.140
데이터를 넣은 곳에요.

00:19:15.140 --> 00:19:18.160
그러나 몇몇 정보는 외부에 두어

00:19:18.160 --> 00:19:20.120
그것에 태그를 붙일 수도 있습니다.

00:19:20.129 --> 00:19:24.369
이것을 유닉스 소켓용 보조 데이터라고 부릅니다.

00:19:27.240 --> 00:19:32.380
그리고 유닉스 소켓을 만드는 방법은

00:19:32.389 --> 00:19:37.480
어드레싱 하는 방식을 바꾸기만 하면 됩니다.

00:19:37.480 --> 00:19:44.280
그래서 IPv6 or IPv4 대신에
AF_UNIX를 유닉스 패밀리 주소로 사용합니다.

00:19:44.280 --> 00:19:50.600
그러고 나서 파일의 경로(path)를 사용할 수 있습니다.

00:19:50.600 --> 00:19:54.580
그리고 클라이언트는 해당 파일에 connect 합니다.

00:19:54.580 --> 00:19:58.139
이것들은 파일 시스템의 정식 파일이기 때문에

00:19:58.139 --> 00:20:01.659
파일 관련 모든 종류의 기능을 사용할 수 있습니다.
파일 권한 설정,

00:20:01.660 --> 00:20:06.720
사용자 그룹 지정,
읽기, 쓰기 sticky 비트 설정,

00:20:07.920 --> 00:20:13.320
파일 관련 인증, 보호 기능을 사용할 수 있습니다.

00:20:13.320 --> 00:20:15.470
소켓 쌍을 만드는 또 다른 방법이 있습니다.

00:20:15.470 --> 00:20:20.050
그것은 a/b 방향으로 끝이 있는 파이프와 같습니다.

00:20:20.050 --> 00:20:24.980
유닉스는 또한 추상 네임 스페이스를 가지고 있습니다.

00:20:24.980 --> 00:20:27.240
저는 그것을 지금 여기서 다루지는 못할 것 같습니다.

00:20:28.080 --> 00:20:31.940
그리고 유닉스 소켓으로 
일반 소켓에서 작동하지 않는 것을 

00:20:31.940 --> 00:20:34.140
실제 할 수 있는 몇 가지가 있습니다.

00:20:35.120 --> 00:20:37.260
peer credential을 얻을 수 있습니다.

00:20:37.260 --> 00:20:41.120
그래서 커널은 파이프의 맞은편에 
누가 있는지 알려줍니다.

00:20:42.320 --> 00:20:44.160
이것은 약간의 예입니다.

00:20:44.160 --> 00:20:45.980
표준 라이브러리에서 현재는 이렇지 않습니다.

00:20:45.980 --> 00:20:47.960
Python 3.6.에서 추가할 계획입니다.

00:20:47.960 --> 00:20:52.039
다른 프로세스의 
PID,

00:20:52.039 --> 00:20:55.419
UID,GID를 얻을 수 있습니다. 

00:20:55.420 --> 00:20:58.460
커널에 의해서 보장되기 때문에

00:20:58.460 --> 00:21:00.620
아무도 그 정보를 (악의적으로) 건드릴 수는 없습니다.

00:21:01.380 --> 00:21:03.380
또 얻어올 수 있는 것은

00:21:03.380 --> 00:21:05.360
만약 리눅스 시스템이라면

00:21:05.360 --> 00:21:07.360
리눅스 context를 가져올 수 있습니다.

00:21:07.360 --> 00:21:11.180
이것도, 다음 버전의 표준 라이브러리에 추가하겠습니다.

00:21:16.380 --> 00:21:19.120
이 기능들을 사용해서

00:21:19.129 --> 00:21:21.489
컨테이너를 이용해서 
매우 멋진 것을 해볼 수 있습니다.

00:21:21.489 --> 00:21:26.860
제가 custodial 프로토콜에서 사용하는
매우 중요한 것 중 하나입니다.

00:21:26.860 --> 00:21:30.780
유닉스 소켓을
컨테이너 간에 사용할 수 있는 기능입니다.

00:21:30.780 --> 00:21:33.560
왜냐하면, 실제 수행 중인 커널 영역은

00:21:33.570 --> 00:21:36.360
가상 머신과 매우 흡사합니다.

00:21:36.360 --> 00:21:42.980
SELinux가 매우 괜찮은 이유로 인해 
조금 더 (사용하기) 어려워질 수도 있습니다.

00:21:42.980 --> 00:21:47.460
Ben Walsh가 SELinux의 유닉스 컨테이너와 관련하여
블로그에 몇 개의 포스팅을 해두었습니다.

00:21:49.420 --> 00:21:52.960
또 다른 한 가지:
컨테이너를 실행할 때,

00:21:52.960 --> 00:21:54.920
각기 다른 네임 스페이스를 가지게 됩니다.

00:21:54.920 --> 00:21:56.940
그래서 컨테이너는 다른 프로세스의 정보를 
볼 수 없습니다.

00:21:56.950 --> 00:21:59.200
그러나 유닉스 소켓으로,

00:21:59.200 --> 00:22:03.289
실제 커널은 PID를 올바르게 해석합니다.

00:22:03.289 --> 00:22:05.669
What about chroot?
(여기서 갑자기 끼어들어서 질문했던 이 사람은
발표가 끝나고 나중에 다시 질문합니다.)

00:22:05.669 --> 00:22:08.060
Later, okay.

00:22:08.060 --> 00:22:13.600
그리고 또한 
다중 카테고리 보안 (Multi-Category Security, MCS) 
분리 라벨을 가져옵니다.

00:22:13.600 --> 00:22:16.780
그래서 모든 컨테이너는 UNIX 라벨이 보장됩니다.

00:22:16.780 --> 00:22:19.360
최근의 모든 컨테이너는 UNIX 라벨을 가지고 있습니다.

00:22:19.360 --> 00:22:24.220
보안 시각화를 사용하는 리눅스 시스템에서요.
(secure visualization)

00:22:24.220 --> 00:22:26.740
이 발표가 도움이 좀 되셨나요?

00:22:26.740 --> 00:22:30.680
실제로 PID로 부터 Docker ID를 가져올 수 있습니다.

00:22:30.680 --> 00:22:33.680
그래서 이렇게 제어 그룹에 있는 cgroup 파일을 
가지고 있습니다.
(/proc/$PID/cgroup)	

00:22:33.680 --> 00:22:35.640
만약 제어그룹 파일을 열어 보신다면

00:22:35.640 --> 00:22:37.660
이렇게 보입니다.

00:22:37.660 --> 00:22:39.680
ID를 좀 줄여서 보여줍니다.

00:22:39.680 --> 00:22:44.480
그리고 해쉬를 할 수가 있는데
이것은 실제 Docker ID입니다.

00:22:45.120 --> 00:22:48.880
더 자세히 보시면

00:22:48.880 --> 00:22:54.040
SELinux 라벨과 일치하는지 확인할 수 있습니다.

00:22:54.040 --> 00:22:57.260
그리고 Kubernetes 또는 OpenShift를
돌려보시면

00:22:57.260 --> 00:23:00.480
컨테이너의 더 많은 정보를 얻을 수 있습니다.
pod,

00:23:00.480 --> 00:23:02.640
name space, and, yeah.

00:23:03.200 --> 00:23:06.880
그리고 그 때문에 -
음, 커널은

00:23:06.880 --> 00:23:09.519
어떤 프로세스도 망쳐놓을 수 없도록 
보호해줍니다.

00:23:09.519 --> 00:23:13.659
커널 혹은 문서 컨테이너

00:23:13.660 --> 00:23:15.680
둘 모두가 손상되지 않는다면

00:23:15.680 --> 00:23:18.920
안전합니다.

00:23:20.410 --> 00:23:24.970
유닉스 소켓을 이용해서 FD를 전송할 수 있습니다.

00:23:24.970 --> 00:23:32.360
그것은 대리용 데이터(surrogate data)를 사용하고 있고, 
그것은 단지 캡슐에 붙어있다고 보시면 됩니다.

00:23:32.360 --> 00:23:36.220
그래서 이러한 기능들은,
예를 들면 멀티 프로세싱을 하고

00:23:36.220 --> 00:23:38.560
표준 라이브 문서에서 사용해왔습니다.

00:23:38.560 --> 00:23:41.520
소켓 모델에는 이것을 실행하는 방법에 대한
예제가 있습니다.

00:23:41.520 --> 00:23:45.020
보기에 좀 별로입니다.
OS에 따라 다릅니다.

00:23:45.020 --> 00:23:48.620
저는 이것 또한 표준 라이브러리 소켓 모델에
추가할 예정입니다.

00:23:49.820 --> 00:23:54.399
FD를 이 사람에서 저 사람에게
보내는 것이 

00:23:54.399 --> 00:23:56.579
유용한 이유는 뭘까요?

00:23:57.360 --> 00:24:00.060
바로 샌드박싱에 매우 유용합니다.
(샌드박스: 외부로부터 들어온 프로그램이 보호된 영역에서
동작하여 시스템에 잘 못 조작되는 것을 막는 보안형태)

00:24:00.070 --> 00:24:02.630
seccomp라는 기능이 있습니다.

00:24:02.630 --> 00:24:05.899
그리고 리눅스 커널이 사용하는 많은 프로그램을

00:24:05.899 --> 00:24:08.999
샌드박스 안에 둡니다.

00:24:09.000 --> 00:24:12.420
그리고 실제로 샌드박스가 
보호해줍니다.

00:24:12.420 --> 00:24:17.220
금지된 시스템콜을 프로세스에서 호출하지 못하도록

00:24:17.220 --> 00:24:19.899
그래서, 이렇게 알려줍니다.
”이 사람은 새로운 프로세스를 만들 수 없습니다.”

00:24:19.899 --> 00:24:23.779
“이 사람은 어떤 파일도 열 수 없고,

00:24:23.780 --> 00:24:27.820
다른 파일의 내용을 (악의적으로) 변경할 수 없고
네트워크 연결을 만들 수 없습니다.”

00:24:28.740 --> 00:24:33.920
그러나 만약 H connection이나 브라우저를 가지고 있다면

00:24:33.920 --> 00:24:37.420
물론 다른 rec 서버와 통신하고 싶어합니다.

00:24:37.420 --> 00:24:39.679
이것을 위해 브로커가 있습니다.

00:24:39.679 --> 00:24:43.230
그래서 아주 아주 간단하게 
다른 프로세스를 

00:24:43.230 --> 00:24:47.220
감시할 수 있고, 
문제를 확인할 수 있습니다.

00:24:47.220 --> 00:24:49.600
플래시보다 훨씬 낫고,

00:24:49.600 --> 00:24:53.190
매우 복잡한 브라우저 렌더러나 VU 렌더러보다
훨씬 낫습니다.

00:24:53.190 --> 00:24:57.790
그래서 이 샌드박스는 브로커에게 요청합니다.
"저 파일을 열어주세요."

00:24:57.790 --> 00:25:01.860
그러면 브로커가 파일을 열고
FD를 돌려보내 줍니다.

00:25:01.860 --> 00:25:06.820
또한, 악의적인 공격에 프로세스가 손상된 경우,

00:25:06.820 --> 00:25:10.960
브로커는 악의적인 인스턴스를 죽일 수(kill) 있습니다.

00:25:10.960 --> 00:25:13.260
그리고, 안전합니다.

00:25:14.700 --> 00:25:19.580
여기서 정말로 다루고 싶은 몇 가지 주제가 있습니다.

00:25:19.580 --> 00:25:24.140
하지만 이제 30초 정도 밖에 없습니다.

00:25:24.140 --> 00:25:26.300
Q&A가 시작하기 전까지요.

00:25:26.300 --> 00:25:28.300
메모리 매핑된 I/O

00:25:28.300 --> 00:25:32.260
이것은 파일을 읽는 것보다 더 많은 것을 할 수 있습니다.

00:25:32.260 --> 00:25:34.620
파일을 메모리에 매핑 할 수 있습니다.

00:25:34.620 --> 00:25:39.940
이것은 멀티 프로세스가 같은 파일에
접근해서 읽기/쓰기를 하는 경우 매우 효과적입니다.

00:25:39.940 --> 00:25:42.100
렌더러도 마찬가지입니다.

00:25:42.100 --> 00:25:45.320
커널이 실제로 파일의 데이터를 메모리에 복사합니다.

00:25:45.330 --> 00:25:47.590
그리고 작업이 끝나면 제거합니다.

00:25:49.320 --> 00:25:51.480
Numpy에서도 지원해줍니다.

00:25:51.480 --> 00:25:54.600
메모리 FD라고 하는 새로운 것이 있습니다.

00:25:54.600 --> 00:25:59.200
파일 같은 것을 실제 메모리에 만들 수가 있고

00:25:59.200 --> 00:26:01.220
봉인해 버릴 수도 있습니다.

00:26:01.220 --> 00:26:03.760
기본적으로 데이터를 쓰고 박스에 봉인할 수 있어서

00:26:03.769 --> 00:26:06.029
아무도 데이터를 수정할 수 없습니다.

00:26:06.029 --> 00:26:10.109
그리고 이 FD를 다른 프로세스에 보내주면 됩니다.

00:26:10.109 --> 00:26:13.149
이것이 임시 파일을 처리하는 
더 나은 방법입니다.

00:26:14.420 --> 00:26:18.520
복사 없이 훨씬 효율적인 I/O를 수행할 수 있습니다.

00:26:18.520 --> 00:26:20.820
커널에서 User 영역으로 복사할 때마다

00:26:20.820 --> 00:26:24.000
그리고 다시 커널 영역으로 돌아갈 때마다

00:26:24.000 --> 00:26:26.360
매우 느린 context switch가 발생합니다.

00:26:26.360 --> 00:26:28.880
데이터를 여러 번 복사해야만 합니다.

00:26:28.880 --> 00:26:32.400
sendfile()과 같은 더 좋은 방법이 있습니다.

00:26:32.400 --> 00:26:34.420
Python은 이미 그것을 사용합니다.

00:26:34.420 --> 00:26:38.560
copy_file_range
이것은 python 3.6.에 추가될 예정입니다.

00:26:38.560 --> 00:26:45.560
splice(), vmsplice(), tee()
이것은 실제 SSL/TLS 소켓으로 

00:26:45.570 --> 00:26:49.220
고성능 파일 서비스를 제공하는데 
매우 유용합니다.

00:26:49.220 --> 00:26:55.809
비용이 많이 드는 TLS를 커널 내부에서 처리합니다.
(Transport Layer Security)

00:26:55.809 --> 00:26:58.969
그리고 마지막으로 
event-driven I/O.

00:26:58.969 --> 00:27:02.360
비동기 I/O에 사용되는 기능입니다.

00:27:02.360 --> 00:27:06.420
수백 개의 네트워크 연결

00:27:06.420 --> 00:27:08.420
혹은 수천개의 네트워크 연결을 가지고 있다면

00:27:08.420 --> 00:27:12.980
이런 종류의 함수를 호출해서 
데이터를 수신하기 위해 대기합니다.

00:27:12.980 --> 00:27:16.480
그리고 파이프가 읽거나, 쓸 준비가 될 때마다

00:27:16.480 --> 00:27:19.980
소켓 연결이 읽고 쓰기를 합니다.

00:27:19.980 --> 00:27:22.000
그리고 프로세스는 이를 통보받습니다.

00:27:22.000 --> 00:27:24.200
그래서 비동기 I/O는 저것들을 사용합니다.

00:27:25.480 --> 00:27:29.279
만약 FD에 대해서 더 많은 것을 알고 싶으시다면

00:27:29.279 --> 00:27:33.459
혹은 Custodial 프로토콜에 대해 
이야기 하고 싶으신 분,

00:27:33.460 --> 00:27:36.800
제가 현재 연구 중인 Custodial 프로토콜의 
개념 증명 관련해서 이야기를 나누실 분은

00:27:36.800 --> 00:27:39.660
오늘 4시에 Open Space에 오셔서 
더 많은 이야기를 했으면 좋겠습니다.

00:27:39.660 --> 00:27:44.320
아래층 C120에 있습니다.

00:27:45.640 --> 00:27:47.620
Thank you very much.

00:27:47.620 --> 00:27:51.460
[applause]

00:27:51.460 --> 00:27:53.520
시간을 거의 맞췄습니다.

00:27:53.520 --> 00:27:56.080
질문을 위한 3분 남았습니다.

00:27:57.880 --> 00:27:59.460
(audience member)
질문 있습니다.

00:27:59.460 --> 00:28:01.240
chroot는 어떨까요?

00:28:01.240 --> 00:28:03.520
Change root?

00:28:03.520 --> 00:28:05.800
마이크 전달해주시겠습니까?

00:28:07.200 --> 00:28:09.200
저기요.

00:28:09.200 --> 00:28:11.020
(audience member)
All right, oh sorry.

00:28:11.020 --> 00:28:12.800
이 발표 주제와 조금은 밀접하게 관련이 
있을지도 모르겠습니다.

00:28:12.800 --> 00:28:15.300
제가 Red Hat을 시작하고,

00:28:15.309 --> 00:28:17.850
python3를 열고,
파일을 엽니다.

00:28:17.850 --> 00:28:20.250
파일에는 non-Unicode 문자열이 있습니다.

00:28:20.250 --> 00:28:22.090
조금 크게 말씀해주시겠어요?

00:28:22.090 --> 00:28:23.870
잘 안 들립니다.

00:28:23.870 --> 00:28:27.180
제가 Red Hat Linux를 실행시키고,

00:28:27.180 --> 00:28:29.920
python3를 시작하고, 파일을 엽니다.

00:28:29.929 --> 00:28:32.509
그리고 파일명에 non-Unicode 문자열이 있습니다.

00:28:33.260 --> 00:28:35.720
어떤 일이 생기고,
어떤 것을 신경을 쓰면 좋을까요?

00:28:35.720 --> 00:28:37.520
항상 제대로 동작합니까?

00:28:37.520 --> 00:28:39.340
좋아요, 그건 실제로 적용되지 않습니다 -

00:28:39.340 --> 00:28:41.320
이미 내부적으로 python에 의해 처리됩니다.

00:28:41.320 --> 00:28:44.460
FD와는 관련이 없습니다.

00:28:44.460 --> 00:28:48.980
Python은 surrogated pairs라는 것을 
(써로게이트 패어: 16비트 1개의 문자에서 
문자에 따라 16비트 2개로 하나의 문자로 표현)

00:28:48.980 --> 00:28:55.759
UTF-8과 일치하도록 바이트를 맞추기 위한 시도를 합니다.

00:28:57.680 --> 00:29:01.040
저는 인코딩과 관련해서는 전문가가 아니긴 하지만

00:29:03.360 --> 00:29:06.760
그것은 커널이나 시스템콜에 의해서 처리되지는 않습니다.

00:29:06.760 --> 00:29:08.720
그것은 python에서 처리됩니다.

00:29:08.720 --> 00:29:11.800
왜냐하면, 유닉스에서의 파일은
실제로 bytes입니다.

00:29:11.809 --> 00:29:14.689
하지만 Python 텍스트로 처리합니다.

00:29:17.000 --> 00:29:18.680
이쪽에는 더 안 계시나요?

00:29:18.680 --> 00:29:20.300
네, 그러면 다시 이쪽 분

00:29:20.300 --> 00:29:22.160
Hello, 먼저 발표중에 끼어들었던 부분은 죄송합니다.

00:29:22.160 --> 00:29:23.900
오늘 발표 감사합니다.

00:29:23.900 --> 00:29:29.860
제 질문은
말씀해주신 것처럼, 컨테이너 사이에 
유닉스 소켓을 전달할 수 있고,

00:29:29.860 --> 00:29:33.240
컨테이너 프로세스 간에 유닉스 소켓을 전달할 수 있는데,

00:29:33.240 --> 00:29:35.840
종종 컨테이너 프로세스들은 chroot를 가지고 있습니다.
그렇죠?

00:29:35.840 --> 00:29:37.820
그것들은 파일 시스템이 무엇인지에 대해
각기 다른 view를 가지고 있습니다.

00:29:37.820 --> 00:29:39.800
그래서 저는 이것이 어떻게 작동하는지 궁금합니다.

00:29:39.800 --> 00:29:41.880
예, 동작합니다.

00:29:41.880 --> 00:29:45.180
파일 기반의 유닉스 소켓을 생성할 수 있습니다.

00:29:45.180 --> 00:29:48.620
만약 유닉스 소켓이 파일 시스템의 파일과 
같은 경우에요.

00:29:48.620 --> 00:29:54.520
그런 다음 해당 디렉터리를 다른 컨테이너에 
mount bind 할 수 있습니다.
(mount bind 기능을 수행하면 
바인드 된 2개의 디렉터리의 내용이 완전히 동일함)

00:29:54.520 --> 00:29:59.880
이것은 컨테이너를 읽기 전용으로 mount bind를 
해도 동작합니다.

00:29:59.880 --> 00:30:01.840
그리고 프로세스가 

00:30:01.840 --> 00:30:04.540
FD를 바꾸거나 제거하지 못하게 합니다.

00:30:04.540 --> 00:30:08.040
FD 복사본은 실제로 device 파일과 비슷합니다.

00:30:08.049 --> 00:30:10.669
그래서 그것은 def 디렉터리에 있습니다.

00:30:10.669 --> 00:30:15.850
FD를 가지고 파일을 열거나 
(내부 통신을 위해) 연결 할 수 있습니다.

00:30:15.850 --> 00:30:17.820
현재 작동하지 않는 부분은

00:30:17.820 --> 00:30:22.460
만약 FD를 생성하는 컨테이너가 하나 있고,

00:30:22.460 --> 00:30:24.840
다른 컨테이너에서 그 FD를 open하려고 하는 경우에
동작하지 않습니다.

00:30:24.840 --> 00:30:30.859
왜냐하면, MCS 라벨링을 하면
관련 없는 컨테이너 간에는 정보를 교환할 수 없게 하기 

00:30:30.859 --> 00:30:33.119
때문입니다.

00:30:33.120 --> 00:30:38.499
또한, 동일한 context에 두기 위해 
몇 가지 설정을 해야 합니다.

00:30:38.499 --> 00:30:44.579
아니면 kernel DBS에서 처리하게 될 것입니다.

00:30:44.580 --> 00:30:50.420
Kernel DBS는 
추가 기능 있는 강화(steroids) 유닉스 소켓입니다.

00:30:50.420 --> 00:30:56.080
또한, 크로스 컨테이너 통신을 할 수도 있습니다.

00:30:56.080 --> 00:30:58.200
다른 방식으로

00:31:01.720 --> 00:31:03.700
네, 그러면 답변을 짧게 요약하자면

00:31:03.700 --> 00:31:06.640
제가 공통 디렉터리를 2개의 컨테이너 모두에 
bind mount 하면 되나요?

00:31:06.640 --> 00:31:09.440
네, 그리고 만약에 -

00:31:09.440 --> 00:31:11.740
기본적으로 브로커의 접근을 잃어버리게 하는 것이 더 쉽습니다.

00:31:11.740 --> 00:31:15.539
만약 호스트 PID 네임 스페이스에서 
실행중인 슈퍼 권한을 가진 컨테이너가 있고,

00:31:15.539 --> 00:31:18.990
FD를 생성하면

00:31:18.990 --> 00:31:21.770
다른 모든 컨테이너들이 그 컨테이너에 연결됩니다.

00:31:21.770 --> 00:31:25.499
그래서 제가 만든 Custodia 컨테이너 관련 예시는

00:31:25.499 --> 00:31:29.839
실제로는 네임스페이스를 호스팅 할 수 있는
권한이 있는 컨테이너입니다.

00:31:29.840 --> 00:31:36.120
현재 SELinux에서는 보안상의 이유로 
동작하지 않습니다.

00:31:36.129 --> 00:31:38.189
매우 좋은 보안상의 이유로요.

00:31:38.189 --> 00:31:39.989
OK, thank you.

00:31:39.989 --> 00:31:41.789
Thank you.

00:31:41.789 --> 00:31:43.729
질문은 여기까지만 받겠습니다.

00:31:43.729 --> 00:31:46.120
Christian님의 Open Space는
4pm부터 시작합니다. 

00:31:46.120 --> 00:31:47.960
Thank you.

00:31:47.960 --> 00:31:49.780
[applause]
