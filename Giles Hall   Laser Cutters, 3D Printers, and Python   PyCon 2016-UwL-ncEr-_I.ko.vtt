WEBVTT
Kind: captions
Language: ko

00:00:08.069 --> 00:00:09.340
안녕하세요.

00:00:09.340 --> 00:00:14.270
와주셔서 고맙습니다.

00:00:14.270 --> 00:00:23.570
저는 오늘 Python을 사용하여 
3D 프린터와 레이저 커터를 사용하기 위해
설계하는 방법에 관해 이야기해 보려고 합니다.

00:00:23.570 --> 00:00:30.090
먼저 제 소개부터 하겠습니다.

00:00:30.090 --> 00:00:35.230
이것은 제 Github과 이메일 주소입니다.

00:00:35.230 --> 00:00:39.120
저는 보스턴에서 Ginko Bioworks라는 
스타트업에서 일합니다.

00:00:39.120 --> 00:00:44.260
우리 회사는 고객을 위한 맞춤형 유기체를 만들기 위해 
합성 생물학 및 유전 공학 기술을 

00:00:44.260 --> 00:00:46.149
이용합니다.

00:00:46.149 --> 00:00:50.870
우리는 수천 개의 맞춤형 변형을 만들고 
이것을 대규모로 수행하기 위해서 

00:00:50.870 --> 00:00:56.469
엔지니어링 샘플을 설계하고 추적 및 분석하는 데 도움이 되는 
Python을 많이 사용합니다

00:00:56.469 --> 00:01:04.149
Ginko에 관심 있으신 분은 ginkobioworks.com에서 
자세한 정보를 얻을 수 있습니다.
그리고 직원 모집합니다.

00:01:04.149 --> 00:01:10.330
저는 한가한 시간에 이것저것 해보는 것을 좋아합니다.
취미로는

00:01:10.330 --> 00:01:16.820
사진촬영, 원예, 자전거 타기, 요리, 전자 장치 만들기 및
작품을 만드는 것 같은 것들이 있습니다.

00:01:16.820 --> 00:01:22.689
제 취미 중 하나로 Python 스크립트 만들기가 있습니다.

00:01:22.689 --> 00:01:24.140
그것은 여러 가지 방법으로 다른 것들을 손쉽게 해줍니다.

00:01:24.140 --> 00:01:27.000
여기 간단한 예가 있습니다.

00:01:27.000 --> 00:01:30.869
저의 집 뒤뜰에는 데이비스 기상대가 있습니다.

00:01:30.869 --> 00:01:37.030
이 기기는 기상정보를 무선으로
집에 있는 라즈베리 파이에 전송합니다.

00:01:37.030 --> 00:01:42.229
모니터링하고 있는 지하실의 라즈베리 파이는
이 데이터를 수신해서 릴레이 세트를 제어합니다.

00:01:42.229 --> 00:01:45.700
기상 상태에 따라서
스프링클러를 켜고 정원에 물을 줍니다.

00:01:45.700 --> 00:01:48.649
그래서 Python은 저에게는 단순한 컴퓨터 언어가 아닙니다.

00:01:48.649 --> 00:01:53.640
그것은 저 자신을 창의적으로 표현하는 데 사용하는 
주요 수단 중 하나입니다.

00:01:53.640 --> 00:02:02.659
Python은 아시다시피 강력한 프로그래밍 언어입니다.
그리고 프로그래밍은 원래 물리적인 매체는 아닙니다.

00:02:02.659 --> 00:02:08.509
Frederick P. Brooks는 제가 가장 좋아하는 
컴퓨터 프로그래밍에 관한 인용문을 책에 썼습니다.

00:02:08.509 --> 00:02:10.950
'맨먼스 미신'에서

00:02:10.950 --> 00:02:14.260
프로그램을 작성하는 것은 시를 짓는 것처럼 
거의 순수에 가까운 사고 영역에서 작업하는 것이다. 
프로그래머는 아무것도 없는 허공에, 
허공으로부터 상상력을 동원하여 성을 쌓는다. 

00:02:14.260 --> 00:02:21.519
이렇게 유연하며, 가다듬고 고치기 쉽고, 
커다란 개념 구상을 쉽게 실현할 수 있는 
창조 매체는 찾아보기 힘들다.

00:02:21.519 --> 00:02:27.220
세상은 놀라운 것들로 가득 차 있지만
컴퓨터의 도움 없이는
(보이지 않는 성 너머에 있는 것처럼) 알아낼 수 없는 것이

00:02:27.220 --> 00:02:29.450
많습니다.

00:02:29.450 --> 00:02:34.440
그림, 조각, 맛난 음식처럼 
당신의 소스 코드를 공유할 수는 없습니다.

00:02:34.440 --> 00:02:39.420
솔직히 말씀드리자면, 
저는 소스 코드를 공유할 수 없다는 건 
거짓이라는 것을 깨달았습니다.

00:02:39.420 --> 00:02:44.209
우리가 매일 우리의 물리적인 세상을 작동하기 위해서 
소프트웨어를 사용하는 것처럼 말입니다.

00:02:44.209 --> 00:02:50.500
아시다시피, 우리의 컴퓨터는 소리와 빛을 내며 
예쁜 문서들을 만들어냅니다.

00:02:50.500 --> 00:02:56.630
실제 세상에 영향을 미칠 수 있는 코드를 만들 수 있는 
수많은 방법이 있습니다.

00:02:56.630 --> 00:03:00.170
그것은 여러분들도 이미 알고 계시는 것이고 
제가 오늘 이야기하고 싶어 하는 것의 핵심입니다.

00:03:00.170 --> 00:03:04.120
짧은 역사를 먼저 되짚어 보겠습니다.

00:03:04.120 --> 00:03:07.870
컴퓨터가 있기 전에 사람들은
손으로 물건을 만들어야 했습니다.

00:03:07.870 --> 00:03:13.540
19세기 후반 ~ 20세기 중반은 전반적으로

00:03:13.540 --> 00:03:20.720
기계 시대(Machine Age)로 알려져 있습니다. 이 기간에, 
산업적 규모로 부품을 많이 만드는 기술을 완성했습니다.

00:03:20.720 --> 00:03:26.610
감산 제조(subtractive manufacturing)라는 
프로세스를 사용해서

00:03:26.610 --> 00:03:33.799
그 기술들에는 
갈기(milling), 세공하기(turning), 천공하기(boring), 
구멍 깎기(broaching), 톱질(sawing), 끊어 내기(reaming),

00:03:33.799 --> 00:03:34.799
드릴로 뚫기(tapping) 같은 기술이 있습니다.

00:03:34.799 --> 00:03:41.320
일반적인 아이디어는 
일종의 부품들을 대량으로 만들어 내는 것이었습니다. 

00:03:41.320 --> 00:03:44.420
매우 정밀하게 재료를 다듬어서

00:03:44.420 --> 00:03:50.850
1950년대 이후 세계는 원자 세대(Atomic Age)에 접어들고
디지털 컴퓨터의 시대를 예고하게 됩니다.

00:03:50.850 --> 00:03:58.000
1940년대와 50년대에 제조 기계 및 공구들은 
펀치 테이프에 의해서 제어되는 전기 모터를 

00:03:58.000 --> 00:04:01.690
사용하게 되었습니다.

00:04:01.690 --> 00:04:06.470
이것이 공장 기계 자동화를 향한 첫걸음이었습니다.

00:04:06.470 --> 00:04:13.470
컴퓨터가 점차 정교해짐에 따라,
컴퓨터 수치 제어라는 새로운 제조 분야가 생겨났습니다.

00:04:13.470 --> 00:04:19.769
CNC라고 알고 있는.

00:04:19.769 --> 00:04:25.760
오늘날에는 제조 분야 전반에 걸쳐서
컴퓨터가 자동으로 제어하고 있습니다.

00:04:25.760 --> 00:04:33.220
컴퓨터 하드웨어와 소프트웨어의 엄청난 발전뿐만 아니라

00:04:33.220 --> 00:04:37.940
몇십 년 전에는 없었던 
새로운 제조 도구들과 프로세스가

00:04:37.940 --> 00:04:39.870
생겨났습니다.

00:04:39.870 --> 00:04:47.050
플라즈마 커터, 워터 제트, 5축 밀링 머신,
석판 인쇄(lithograph)

00:04:47.050 --> 00:04:53.760
그리고 제가 가장 좋아하는 2가지는
레이저 커터와 3D 프린터입니다.

00:04:53.760 --> 00:04:59.210
레이저 커터와 3D 프린터 각각을 기술적으로 확인해보겠습니다.

00:04:59.210 --> 00:05:05.230
그리고 Python을 사용하여 이러한 툴을 사용하기 위해
설계하는 방법에 관해서 이야기해 보겠습니다.

00:05:05.230 --> 00:05:10.340
먼저 레이저 커터.

00:05:10.340 --> 00:05:16.620
레이저 커터는 다양한 재료를 에칭 또는 절단하기 위해

00:05:16.620 --> 00:05:18.440
고성능 레이저를 사용하는 장치입니다.

00:05:18.440 --> 00:05:22.650
가장 상업적으로 이용 가능한 레이저 커터는

00:05:22.650 --> 00:05:30.930
종이, 목재, 플라스틱, 가죽, 직물을
일정한 두께로 자르고 에칭할 수 있습니다.

00:05:30.930 --> 00:05:35.430
그리고 레이저 튜브 자체는 보통 기계의 뒤쪽에 
고정되어 있습니다.

00:05:35.430 --> 00:05:41.000
정밀하게 배치된 거울은 레이저 빔을
레이저 헤드로 반사 시킵니다.

00:05:41.000 --> 00:05:49.120
레이저 헤드 자체는 거울과 렌즈로 구성되어 있고
레이저 빔을 타겟 물질에 모읍니다.

00:05:49.120 --> 00:05:55.730
스테퍼 모터는 작업물과 평행한 X, Y 평면에서 

00:05:55.730 --> 00:06:01.920
레이저 헤드를 움직이고, 
레이저는 주어진 설계의 윤곽을 따라갑니다.

00:06:01.920 --> 00:06:08.090
레이저 커터는 정교하게 설계된 세부사항들을
믿을 수 없을 정도로 

00:06:08.090 --> 00:06:13.490
정확하게 커팅합니다.

00:06:13.490 --> 00:06:18.370
일반적으로 
레이저 커터용 디지털 설계는 벡터 그래픽으로 시작합니다.

00:06:18.370 --> 00:06:24.110
어도비 일러스트 레이터와 Inkscape 같은 설계 프로그램은
벡터 일러스트 레이터

00:06:24.110 --> 00:06:25.330
패키지입니다.

00:06:25.330 --> 00:06:32.430
이것은 Gimp 또는 Photoshop과 같은
래스터 또는 비트맵 지향 그래픽 패키지와

00:06:32.430 --> 00:06:34.430
대조되는 프로그램입니다.

00:06:34.430 --> 00:06:39.430
벡터 그래픽을 사용하면 
레이저 커터의 동작을 제어하는 소프트웨어로 쉽게

00:06:39.430 --> 00:06:45.670
그래픽을 모션으로 변환할 수 있습니다.

00:06:45.670 --> 00:06:51.160
레이저 커터용 설계를 만드는 과정은 비교적 간단합니다. 

00:06:51.160 --> 00:06:56.080
외형을 구상하여 설계한 후에
사용하려는

00:06:56.080 --> 00:06:58.160
재료의 종류와 크기를 선택합니다.

00:06:58.160 --> 00:07:04.950
일반적으로,
레이저 커터로 커팅할 때는 얇은 것이 두꺼운 것보다 낫습니다.

00:07:04.950 --> 00:07:11.940
커팅하려는 재료의 제약 조건에 따라서 
설계할 때 크기를 조절해야 합니다.

00:07:11.940 --> 00:07:18.550
그러나 벡터 그래픽을 사용하면
설계에 충실하면서도 손실 없이 설계를 확장할 수

00:07:18.550 --> 00:07:23.620
있습니다.

00:07:23.620 --> 00:07:27.840
대부분의 레이저 커터용 설계는 어느 부분을 자르고, 
에칭해야 하는지에 대한 정보가 필요합니다.

00:07:27.840 --> 00:07:34.610
이것은 라인의 색상으로 설정할 수 있습니다.

00:07:34.610 --> 00:07:40.020
예를 들어, 빨간색은 절단, 파란색은 에칭

00:07:40.020 --> 00:07:44.120
그런 다음 커팅할 준비가 되면

00:07:44.120 --> 00:07:50.560
재료를 레이저 베드에 올리고 레이저 빔에 초점을 맞춘 다음
설계 파일을 업로드합니다.

00:07:50.560 --> 00:07:52.730
솔직히 레이저 커터마다 조금씩 차이는 있습니다.

00:07:52.730 --> 00:07:58.060
실제로 커팅이 어떻게 이루어질지에 대한 세부 사항들은

00:07:58.060 --> 00:08:02.600
그 커터를 만드는 회사에 의해 결정되어서 그렇습니다.

00:08:02.600 --> 00:08:11.990
EPS에 설계한 것을 PDF 파일로 업로드 할 수는 있지만
개인적으로 SVG를 선호합니다.

00:08:11.990 --> 00:08:18.720
SVG 파일은 XML 문서이며 HTML과 아주 유사합니다.

00:08:18.720 --> 00:08:27.100
HTML과 SVG는 너비, 높이, 스타일 및 테두리와 같은 
다양한 태그에 대한 많은 tag name을 

00:08:27.100 --> 00:08:28.760
공유합니다.

00:08:28.760 --> 00:08:34.680
문법 스타일도 공유합니다.
SVG의 최신 개정판에서는 종속형 시트(CSS)도 

00:08:34.680 --> 00:08:36.949
지원합니다.

00:08:36.949 --> 00:08:40.969
SVG 문서의 간단한 예입니다.

00:08:40.969 --> 00:08:47.270
두 개의 태그입니다. 
사각형은 rec, 원은 circ

00:08:47.270 --> 00:08:52.580
직사각형 태그는 왼쪽 위 모서리를 정의하기 위해
x, y 좌표를 가져오고

00:08:52.580 --> 00:08:55.180
크기를 정의하는 폭과 높이의 값을 가져옵니다.

00:08:55.180 --> 00:08:59.820
반면에 원은
그 중심을 정의하는 x, y 좌표와

00:08:59.820 --> 00:09:06.360
반지름 정보가 필요합니다.
이 객체들 각각은 도형이 어떻게 채색되고 채워지는지, 
즉 어떤 색으로 채워지는지를 

00:09:06.360 --> 00:09:11.200
정의하는 매개 변수를 가져옵니다.

00:09:11.200 --> 00:09:20.440
아시다시피, SVG를 사용하면 몇 줄의 코드로 
비교적 복잡한 설계를 할 수 있습니다.

00:09:20.440 --> 00:09:28.130
SVG의 개인적으로 가장 좋아하는 기능은 Path입니다.

00:09:28.130 --> 00:09:34.650
Path는 복잡한 다각형을 만드는 데 사용할 수 있게
서로 연결된 단순한 선들의 모음입니다.

00:09:34.650 --> 00:09:39.280
Path 세그먼트는 직선이거나 
제어점이 있는 스플라인 곡선(curve spline)일 수 있습니다

00:09:39.280 --> 00:09:45.390
SVG 문서에 따르면, path는 문자 스트링으로 정의합니다.

00:09:45.390 --> 00:09:52.820
그것은 이동을 위한 m이나 
라인을 위한 l과 같은 단일 문자 명령과

00:09:52.820 --> 00:09:58.640
해당 명령의 좌표를 나타내는 2개 이상의 숫자로 나뉩니다.

00:09:58.640 --> 00:10:03.510
원과 사각형만으로도 많은 일을 할 수는 있습니다.
하지만 Path를 사용하면 매우 복잡한 도형을 만들 수 있습니다.

00:10:03.510 --> 00:10:09.450
이 예제에서 
저는 이 물결 모양의 선을 만들기 위해 

00:10:09.450 --> 00:10:12.540
몇 개의 임의의 점을 움직였습니다.

00:10:12.540 --> 00:10:19.899
오늘 말씀드릴 이야기를 위해 핑거(단위) 마디를 사용하여 
레이저 커터로 큐브 또는 상자를 만들어주는 
Python 프로그램을 만들었습니다.

00:10:19.899 --> 00:10:28.920
2차원 설계이지만

00:10:28.920 --> 00:10:32.899
퍼즐처럼 합쳐서 3차원을 만들어냅니다.

00:10:32.899 --> 00:10:37.410
프로그램 자체는 몇백 줄로 구성되어 있습니다.
그래서 지금 그 전체를 이야기할 수는 없습니다.

00:10:37.410 --> 00:10:45.650
하지만 지금 발표 이후에 제 GitHub에 가서 코드와 
다양한 옵션들을 확인하실 수 있습니다.

00:10:45.650 --> 00:10:52.140
그것으로 본인이 직접 설계를 할 수 있습니다.

00:10:52.140 --> 00:10:56.910
오늘 저는 많은 예제를 가져왔습니다. 
그래서 저를 찾아오시면 그 예제들을 보여 드릴 수 있습니다.

00:10:56.910 --> 00:11:05.330
그리고 경매에 부칠 거에요.
PyLadies Auction에서.

00:11:05.330 --> 00:11:10.490
이것은 생성된 설계 중 하나인데

00:11:10.490 --> 00:11:13.080
레이저 커팅 제어 소프트웨어에 
data 그대로(축어적으로) 전송되는 것처럼 보입니다.

00:11:13.080 --> 00:11:17.560
설계한 레이아웃의 서로 다른 면을 
아주 가깝게 하는 것을 볼 수 있습니다.

00:11:17.560 --> 00:11:20.900
이것은 재료의 전반적인 낭비를 최소화합니다.

00:11:20.900 --> 00:11:26.510
그리고 그것이 똑같은 면이 아닌 것을 
반복해서 볼 수 있습니다.

00:11:26.510 --> 00:11:30.420
각각의 면마다 조금씩 다릅니다.

00:11:30.420 --> 00:11:36.640
그리고 그것은 퍼즐과 같은 방식으로 서로 합쳐집니다.

00:11:36.640 --> 00:11:45.410
이것은 나무판에 그 설계를 이용해서 커팅한 결과입니다.

00:11:45.410 --> 00:11:51.279
재료가 레이저로 점화되는 순간
약간 불타서 불에 탄 흔적이 

00:11:51.279 --> 00:11:53.540
남아있습니다.

00:11:53.540 --> 00:12:00.330
보너스로 나무 보드가 불에 탈 때 발생하는
상큼한 냄새를 맡을 수 있습니다.

00:12:00.330 --> 00:12:06.100
각 면의 모서리가 서로 맞아야
큐브가 퍼즐처럼 서로 합칠 수 있습니다.

00:12:06.100 --> 00:12:14.790
제 생각에 이들 엣지는 +와 -로 나뉘는 것 같습니다.

00:12:14.790 --> 00:12:19.200
바깥쪽 엣지를 가지고 있느냐 
안쪽 엣지를 가지고 있느냐에 따라서.

00:12:19.200 --> 00:12:22.290
그리고 이것을 구별하기 위해서 색으로 구분했습니다.

00:12:22.290 --> 00:12:30.350
그래서 
이 경우 빨간색은 +(positive)이고 녹색은 -(negative)입니다.

00:12:30.350 --> 00:12:36.480
우리가 모뎀을 다이얼인 하는 것과 같이
단 하나의 면에 대해 단 하나의 엣지를 생각하고 

00:12:36.480 --> 00:12:43.209
그것을 생성하기 위해서 작성해야 할 코드를 
고민해볼 수 있습니다.

00:12:43.209 --> 00:12:48.030
재료의 너비에 따라 각 핑거 폭에 대한 높이가 결정됩니다.

00:12:48.030 --> 00:12:53.050
설계에 필요한 핑거 폭의 수와 결합 된 엣지의 길이는

00:12:53.050 --> 00:12:56.680
핑거 폭의 전체 너비를 결정합니다.

00:12:56.680 --> 00:13:04.200
따라서 이렇게 변경 가능한 매개 변수를 이용하여
단일 엣지를 그려주는 함수를 작성할 수 있습니다.

00:13:04.200 --> 00:13:08.290
이것이 바로 그 코드입니다.

00:13:08.290 --> 00:13:14.670
이 함수는 큐브 면의 크기를 1개의 튜플, 엣지에 있는 핑거 수, 

00:13:14.670 --> 00:13:18.660
한 핑거의 너비 및 재료의 두께정보를 가져옵니다.

00:13:18.660 --> 00:13:22.750
그리고 다양한 기하학적인 오프셋을 연산합니다.

00:13:22.750 --> 00:13:27.060
먼저 우리는 그 중심점을 찾기 위해 면의 크기를 사용합니다.

00:13:27.060 --> 00:13:30.500
핑거 넓이의 핑거 수를 가지고 우리는 중심 위치를 사용하여 

00:13:30.500 --> 00:13:38.470
엣지 선에서 
첫 번째 시작점이 발생해야 하는 위치를 계산합니다.

00:13:38.470 --> 00:13:45.000
그리고 핑거 너비와 핑거 깊이에 대한 
두 개의 위치 오프셋 목록을 만듭니다.

00:13:45.000 --> 00:13:53.500
엣지를 따라 각 점을 반복하면서 각각의 점에 대한 오프셋을 

00:13:53.500 --> 00:13:54.890
연산합니다.

00:13:54.890 --> 00:14:00.360
이 코드는 첫 번째, 세 번째 지점마다 엣지가 앞으로 가고
두 번째 지점마다 엣지가 올라가고

00:14:00.360 --> 00:14:05.450
네 번째 지점마다 내려간다는 규칙을 이용합니다.

00:14:05.450 --> 00:14:14.240
그래서 엣지 프로 파일을 생성할 때 modulus 연산자를 사용하여 
이러한 오프셋을 재생합니다. 

00:14:14.240 --> 00:14:17.810
이전 함수(previous function)를 어떻게 호출할 것인지에 대한 
예가 있습니다.

00:14:17.810 --> 00:14:22.529
이전 함수는 위치 리스트를 반환하는 생성기이므로 

00:14:22.529 --> 00:14:29.339
호출자는 해당 지점을 가져와서 
SVG path로 포맷된 문자열로 변환합니다.

00:14:29.339 --> 00:14:35.550
첫 번째 명령이 M 명령에 있음을 알 수 있습니다. 
왜냐하면, 그 위치로 이동하려고 하기 

00:14:35.550 --> 00:14:36.550
때문입니다.

00:14:36.550 --> 00:14:43.110
그런 다음 L 명령을 사용하여 연결된 선을 그릴 수 있습니다.

00:14:43.110 --> 00:14:47.580
이것이 그 결과입니다.

00:14:47.580 --> 00:14:52.910
이것은 분명히 전체 상자 생성기의 작은 부분이지만,

00:14:52.910 --> 00:14:55.570
설계의 핵심입니다.

00:14:55.570 --> 00:14:59.390
코드는 객체 지향적이며 따라 하기가 상대적으로 쉽습니다.

00:14:59.390 --> 00:15:04.410
상자의 크기, 재료의 두께, 상자 면의 설계 변경은
많은 다른 방법으로 그것을 본인 취향에 맞게 바꿀 수 

00:15:04.410 --> 00:15:10.600
있습니다.

00:15:10.600 --> 00:15:17.820
예를 들어 박스 생성기 자체는 

00:15:17.820 --> 00:15:24.300
각 면에 대한 기하학적인 규칙을 정의하는 
기본 클래스가 있어서, 이 클래스를 상속하여 
렌더링 메서드에 연결할 수 있습니다.

00:15:24.300 --> 00:15:28.910
이 예제에서는 Fermat's spiral을 추가했습니다. 

00:15:28.910 --> 00:15:34.339
이것은 해바라기에서 발견할 수 있는 씨앗의 패턴을 연상시키는
패턴을 생성하는 간단한 수학적인 함수입니다.

00:15:34.339 --> 00:15:45.670
이것을 생성하기 위해 사용되는 코드입니다.

00:15:45.670 --> 00:15:49.430
이를 자세히 다루기보다는 오히려 

00:15:49.430 --> 00:15:59.269
그런 재미있는 코드(아티팩트)를 만들어 내고 
더 큰 설계에 부분적으로 그것을 포함할 수 있는

00:15:59.269 --> 00:16:01.790
아이디어를 강조하고 싶습니다.

00:16:01.790 --> 00:16:07.250
만들려는 설계에 멋을 더해주는 
코드(아티팩트)를 추가하기 위한 객체의 종류를 알아내면

00:16:07.250 --> 00:16:16.580
그다음부터는 매우 쉽게 처리할 수 있습니다.

00:16:16.580 --> 00:16:23.680
이것은 생성된 결과 이미지입니다.

00:16:23.680 --> 00:16:30.589
SVG는 파일의 전체 구조를 변경하지 않고도
새로운 요소(element)를 레이어에 추가하거나 

00:16:30.589 --> 00:16:36.019
설계를 추가하기가 매우 쉽습니다.

00:16:36.019 --> 00:16:42.680
Python과 결합하여 레이저 절단용 설계를 
나타내는 것은 완벽한 기술입니다.

00:16:42.680 --> 00:16:44.790
Whoops.

00:16:44.790 --> 00:16:48.930
다음은 3D 프린터.

00:16:48.930 --> 00:16:53.710
3D 프린터는 3차원 물체를 만들 수 있는 장치입니다.

00:16:53.710 --> 00:16:55.780
가격과 복잡도는 다양합니다.

00:16:55.780 --> 00:17:02.670
사용 가능한 가장 일반적인 3D 프린터는 
퓨즈 증착 모델로 알려져 있습니다.

00:17:02.670 --> 00:17:07.970
이 작업은 3차원 객체를 2차원 슬라이스로 분해하여 
다른 객체의 위에 하나를 쌓아 올리면서

00:17:07.970 --> 00:17:12.660
3차원 객체의 형상을 재구성합니다.

00:17:12.660 --> 00:17:18.600
FDM 프린터는 특히 고온에서 플라스틱을 압출하여 작동합니다.

00:17:18.600 --> 00:17:23.329
그러나 레이저 커터와 달리 3D 프린터는 
두 개가 아닌 세 개의 축에서 작동합니다.

00:17:23.329 --> 00:17:28.720
x, y축을 프린트 헤드가 사용하여 
재료를 원하는 형상으로 증착한 다음 

00:17:28.720 --> 00:17:36.869
z축을 사용하여 모델을 다음 2차원 슬라이스로 움직입니다

00:17:36.869 --> 00:17:40.450
이것은 높은 수준의 3D 프린터용 설계 파이프라인입니다.

00:17:40.450 --> 00:17:46.809
대부분의 3D 인쇄는 STL 파일을 사용하고 
GCODE 파일을 생성합니다.

00:17:46.809 --> 00:17:52.299
STL 파일은 실제로 삼각형 메쉬 형태로 
3차원 객체를 표현하기 때문에

00:17:52.299 --> 00:17:56.590
직접 생성하기가 쉽지 않습니다.

00:17:56.590 --> 00:18:01.470
개인적으로 삼각형의 메쉬로 알고 있는 3차원 설계에 대해서는 
고려하지 않았습니다.

00:18:01.470 --> 00:18:05.889
저는 그것들을 단단한 물체(solid object)라고 
생각하고 싶습니다.

00:18:05.889 --> 00:18:11.009
약 5년 전 제 여자친구와 저는 
우리의 첫 번째 3D 프린터를 구매하고는 너무 신났었습니다.

00:18:11.009 --> 00:18:15.940
우리가 생각만 하던 물건들을 
직접 설계하고 만들어 낼 수 있다는 사실들에

00:18:15.940 --> 00:18:17.109
말이죠.

00:18:17.109 --> 00:18:22.409
하지만 사람들이 일반적으로 
인쇄용 CAD 모델을 설계하는 데 사용하는 

00:18:22.409 --> 00:18:25.980
표준화된 툴을 보고 금방 좌절감을 느꼈습니다.

00:18:25.980 --> 00:18:31.220
저는 Sketchup과 같은 프로그램에서 
복잡한 설계를 구축하는 데만 시간을 할애해왔는데

00:18:31.220 --> 00:18:35.649
이제는 코어 쪽에서 모델 쪽으로 
옮겨야 할 때가 왔다는 것을 깨달았습니다.

00:18:35.649 --> 00:18:40.299
설계 도구의 대부분은 이러한 과감한 변화를 주기가 
쉽지 않습니다.

00:18:40.299 --> 00:18:47.080
그것은 가족 초상화를 그리는 것과 같고, 
형제를 내치는 것과 비슷합니다.

00:18:47.080 --> 00:18:53.909
그 밖에도 정교한 3D 모델러가 있는데, 
그중 일부 모델은 파라 메트릭(Parametric) 모델입니다.

00:18:53.909 --> 00:18:59.859
그러나 대부분은 
비싸거나 윈도우OS에서만 실행되거나 배우기가 어렵거나

00:18:59.859 --> 00:19:00.960
일반적으로 3가지 모두에 해당합니다. (접하기 어려움)

00:19:00.960 --> 00:19:05.049
저에게 익숙한 프로그래밍 방식의 솔루션을 찾아보았습니다.

00:19:05.049 --> 00:19:13.629
그리고 OpenSCAD라고 하는 
제가 사용하기 편리한 솔루션을 찾았습니다.

00:19:13.629 --> 00:19:15.480
OpenSCAD는 공간기하학 구조를 사용합니다.

00:19:15.480 --> 00:19:21.460
아이디어는 큐브, 실린더, 구체와 같은 
2차원 및 3차원 기본 요소로부터 

00:19:21.460 --> 00:19:23.740
객체를 만들어가는 것입니다.

00:19:23.740 --> 00:19:29.149
객체들을 한 공간에 배치한 다음 
이들 객체 간에 논리 연산(Boolean operator)을 정의합니다.

00:19:29.149 --> 00:19:35.880
가장 일반적인 논리 연산은 두 개 이상의 입체를 
하나로 결합하는 합집합(Boolean Union)입니다.

00:19:35.880 --> 00:19:42.389
그리고 하나 이상의 입체를 다른 것에서 빼는 데 사용하는
차(Boolean Difference)가 있습니다.

00:19:42.389 --> 00:19:46.659
유리잔을 예로 들면

00:19:46.659 --> 00:19:51.659
이것을 단지 두 개의 실린더로 구성할 수 있습니다.

00:19:51.659 --> 00:19:56.539
첫 번째 실린더. 죄송합니다. 
윗부분이 안 보이지만, 나중에 코드를 볼 수 있습니다.

00:19:56.539 --> 00:20:01.450
첫 번째 실린더는 바깥면을 나타내고
두 번째 실린더는 내부의 빈 공간을

00:20:01.450 --> 00:20:03.139
나타냅니다.

00:20:03.139 --> 00:20:09.190
OpenSCAD를 사용하여 첫 번째 실린더 안에
두 번째 실린더가 있다는 것을 정의합니다.

00:20:09.190 --> 00:20:16.230
내부 실린더는 z축 또는 상향 축에 의해서 오프셋 되고

00:20:16.230 --> 00:20:21.359
외부 실린더보다 작은 반경을 가집니다.

00:20:21.359 --> 00:20:25.409
그런 다음 컵의 빈 공간을 만들기 위해 
외부 실린더에서 내부 실린더를

00:20:25.409 --> 00:20:26.570
뺍니다.

00:20:26.570 --> 00:20:32.909
이 작업을 하려면 유리잔을 바닥에 둬야 합니다.

00:20:32.909 --> 00:20:38.539
그러나 유리잔의 입구를 만들어야 하므로 
우리는 오프셋을 수행합니다.

00:20:38.539 --> 00:20:48.009
여기 두 실린더가 어떻게 생겼는지를 보여줍니다.
두 번째 또는 세 번째 줄의 코드에서

00:20:48.009 --> 00:20:50.940
translate 연산이 있습니다.

00:20:50.940 --> 00:20:57.350
그리고 내부 실린더를 위로 움직여서 유리잔의 바닥과 입구를

00:20:57.350 --> 00:21:00.649
만듭니다.

00:21:00.649 --> 00:21:07.710
지금 저는 이 두 실린더가 끼워져있다는 사실을 강조하는

00:21:07.710 --> 00:21:15.090
두 객체의 결합체로 이것을 가지고 있습니다.

00:21:15.090 --> 00:21:20.649
최상단을 Union에서 Difference로 바꿔서 
우리가 목표로 하는 컵의 빈 공간을 만듭니다.

00:21:20.649 --> 00:21:25.960
OpenSCAD는 이러한 객체에 대한 메쉬를 계산하기 위해 
모든 어려운 복잡한 수학 연산을 수행하므로 

00:21:25.960 --> 00:21:33.730
원시적인 형태의 모델을 구성하는 방법에 대해 
생각해 볼 수 있습니다.

00:21:33.730 --> 00:21:37.129
저는 단지 4줄의 코드만으로 이것을 구축해 볼 수 있다는 것은

00:21:37.129 --> 00:21:38.529
인상적이라고 생각합니다.

00:21:38.529 --> 00:21:42.600
그러나 OpenSCAD용 스크립팅 언어는 상대적으로 단순하고

00:21:42.600 --> 00:21:47.480
Python에서 우리가 알고 사랑하는 많은 기능을 
제공하지는 않습니다.

00:21:47.480 --> 00:21:54.009
우리는 OpenSCAD의 단순성이 무엇인지 알고 있고,

00:21:54.009 --> 00:21:57.679
Python을 이용해서 OpenSCAD용 파일을 만들어 낼 수 있습니다.

00:21:57.679 --> 00:22:02.860
그래서 더 복잡한 예를 들어, 화분을 생각해보겠습니다.

00:22:02.860 --> 00:22:07.379
화분은 술잔과 비슷하지만 몇 가지 독특한 특징이 있습니다.

00:22:07.379 --> 00:22:12.090
첫째, 화분 대부분은 상단이 넓고 하단이 좁습니다.

00:22:12.090 --> 00:22:16.259
우리는 모양이 원뿔이라고 생각하지만, 

00:22:16.259 --> 00:22:22.229
OpenSCAD에서는 각 끝에 2개의 다른 반경을 가진 원통으로 
정의할 수 있어서 보통 원통형이라고 설명됩니다.

00:22:22.229 --> 00:22:27.309
둘째, 물의 배수를 쉽게 하기 위한 구멍이 바닥에 있습니다. 

00:22:27.309 --> 00:22:33.169
마지막으로 화분을 들어 옮기기 편하게 하기 위한 
가장 윗부분의 가장자리에 손잡이(collar)가 있습니다.

00:22:33.169 --> 00:22:39.470
이제 우리는 OpenSCAD 문법에 대한 감을 잡았으니 

00:22:39.470 --> 00:22:42.279
Python으로 어떻게 설계를 할 수 있는지 이야기해 봅시다.

00:22:42.279 --> 00:22:46.269
OpenSCAD용 코드를 만들 수 있게 해주는 
Python 라이브러리들이 있습니다.

00:22:46.269 --> 00:22:51.350
제가 작성한 pyscad라는 Python 라이브러리를 포함해서.

00:22:51.350 --> 00:22:58.100
라이브러리 대부분은 Python 클래스로 
OpenSCAD의 정의를 래핑하는 방식으로 비슷하게 동작합니다.

00:22:58.100 --> 00:23:02.330
제 데모에서는 제 라이브러리를 사용하지만, 

00:23:02.330 --> 00:23:06.259
여러분은 다른 라이브러리들도 사용하실 수 있습니다.

00:23:06.259 --> 00:23:10.960
제가 Python으로 작성하기 시작한 대부분의 SCAD 객체들은 
일련의 파라 메트릭(parametric) 변수를 가지고 

00:23:10.960 --> 00:23:15.330
객체의 물리적 제약 조건을 정의하는 것을 돕습니다.

00:23:15.330 --> 00:23:21.649
유연하게 설계한 몇 개의 최상위 변수들을 작성한 다음 

00:23:21.649 --> 00:23:25.929
이러한 초기값을 바탕으로 다른 변수값을 계산합니다.

00:23:25.929 --> 00:23:30.970
이 예제에서 화분의 전체 높이에서 파생된 꽃 부분에 대한

00:23:30.970 --> 00:23:32.889
많은 변수가 있습니다.

00:23:32.889 --> 00:23:37.729
이렇게 하면 개별 변수들을 변경하지 않고도 
화분의 전체 크기를 쉽게 수정할 수

00:23:37.729 --> 00:23:40.499
있습니다.

00:23:40.499 --> 00:23:46.609
아시다시피,
예를 들어 상단 반경과 하단 반경을 정의하는 

00:23:46.609 --> 00:23:52.460
비율이 있다는 것을 알 수 있습니다.
저의 집 주변의 화분을 조사한 결과,

00:23:52.460 --> 00:23:59.080
일반적으로 약 0.6 비율이었습니다.

00:23:59.080 --> 00:24:05.879
화분 자체의 두께 혹은 화분 내벽의 두께 같은 것들에 따라서

00:24:05.879 --> 00:24:12.259
그것들을 빼내기 위한 우리의 오프셋을 연산해야 합니다.

00:24:12.259 --> 00:24:17.369
이것은 그 화분을 만드는 데 필요한 모든 코드입니다. 
솔직히 말씀드리자면,

00:24:17.369 --> 00:24:24.250
레이저 커터용 큐브보다 훨씬 간단합니다. 
실제로 좀 지루합니다.

00:24:24.250 --> 00:24:30.529
바깥쪽에서 시작하여 우리가 필요로 하는 공간을 파내기 위해 
다른 실린더를 추가합니다.

00:24:30.529 --> 00:24:36.389
unions and translations로 실린더 초기 모델을 만들었습니다.

00:24:36.389 --> 00:24:40.440
정말 어려운 부분은 모델을 상상해 본 다음 
부분별로 분해하는 것입니다.

00:24:40.440 --> 00:24:48.809
일단 분해를 하고 나면,
설계하고 코드를 작성하는 것은 매우 간단합니다.

00:24:48.809 --> 00:24:57.029
이것은 저의 집에 있는 3D프린터로 
여기에 2.5인치(6.35cm) 크기의 화분을 만들고 있습니다.

00:24:57.029 --> 00:25:01.679
인쇄하는 데 약 2시간이 걸렸지만

00:25:01.679 --> 00:25:05.059
설계 일부가 아닌 
외벽을 인쇄하고 있다는 것을 눈치채셨을 것입니다.

00:25:05.059 --> 00:25:10.909
이 외벽은 3D 프린터 소프트웨어에 의해 생성되며 
보조제(support material)로 알려져 있습니다.

00:25:10.909 --> 00:25:16.279
화분의 손잡이로 튀어나온 부분은
보조제(support material) 소재가 없으면 

00:25:16.279 --> 00:25:19.129
3D 프린터는 튀어나온 부분을 제대로 인쇄할 수 없습니다.

00:25:19.129 --> 00:25:27.700
인쇄가 끝나면 떼어 낼 수 있습니다. 
완성된 결과물입니다.

00:25:27.700 --> 00:25:37.789
이제 저는 레이저 커터와 3D 프린터로 수행한 
더 복잡한 두 가지 프로젝트에 관해 이야기할 것입니다.

00:25:37.789 --> 00:25:42.110
그리고 이 코드는 이들 프로젝트에서 사용할 수 있습니다.

00:25:42.110 --> 00:25:47.359
이 단순한 예제 들은 단순한 맛보기입니다.

00:25:47.359 --> 00:25:50.059
이 코드들을 바탕으로 
여러분들은 더 많은 것을 해볼 수 있습니다.

00:25:50.059 --> 00:25:56.009
처음 시작한 것은 눈송이 생성기입니다.

00:25:56.009 --> 00:26:04.690
몇 가지…
이 프로젝트는 제 여자 친구와 약 4년 전에 시작했었습니다.

00:26:04.690 --> 00:26:10.440
우리는 휴일 동안 
우리의 친구와 가족들과 어떻게 보낼지 생각해 보았습니다.

00:26:10.440 --> 00:26:16.539
그리고 레이첼은 눈송이가 만들어지는 과정을 
시뮬레이션할 수 있게 물리적 모델을 설명해주는 
이 놀라운 논문을

00:26:16.539 --> 00:26:17.539
발견했습니다.

00:26:17.539 --> 00:26:22.580
이 논문의 수식을 Python 코드로 만들어 내고

00:26:22.580 --> 00:26:27.139
우리의 선물 리스트에 있는 
모든 사람을 위해 맞춤화된 눈송이를 만들기 시작했습니다.

00:26:27.139 --> 00:26:34.330
이 모델은 중간보기적(mesoscopic) 레벨에서 작동합니다. 

00:26:34.330 --> 00:26:41.369
즉, 분자 집합, 
특히 물 분자를 한정되지 않은 단위로 모델링 합니다

00:26:41.369 --> 00:26:49.529
먼저 육각형 그리드를 구성하여 시작합니다. 
그리드는 물 분자의 균일한 필드로 채워집니다.

00:26:49.529 --> 00:26:53.470
이들 물 분자는 
인접한 하나의 셀로부터 다른 하나의 셀로 이동할 수 있고,

00:26:53.470 --> 00:26:59.950
수증기(vapor), 경계(boundary), 얼음(frozen)
3가지 상태로 전환할 수 있습니다.

00:26:59.950 --> 00:27:05.470
경계(boundary) 상태는 보통 
수증기(vapor)도 아니고 얼음(frozen)도 아닌

00:27:05.470 --> 00:27:08.820
어중간한 상태의 물을 표현하는 데 사용합니다.

00:27:08.820 --> 00:27:14.340
물 분자의 초기 필드는 중간에 있는 셀을 제외하고는

00:27:14.340 --> 00:27:17.450
수증기(vapor) 상태로 설정됩니다.

00:27:17.450 --> 00:27:23.389
그런 다음 시뮬레이션이 실행되고 
눈송이가 만들어지기 시작합니다.

00:27:23.389 --> 00:27:28.460
모델은 알고리즘에서 이러한 단계별 동작을 지시하기 위해

00:27:28.460 --> 00:27:30.700
8개의 서로 다른 매개 변수를 사용합니다.

00:27:30.700 --> 00:27:37.669
그래서 각 셀의 상태에 대해 개별적으로 연산합니다.

00:27:37.669 --> 00:27:45.669
먼저 수증기가 어떻게 되는지, 
수증기가 어떻게 이동해야 하는지를 파악합니다. 

00:27:45.669 --> 00:27:51.629
그리고서 그중 일부가 얼음에서 수증기의 경계(boundary)로
되어야 하는지를 계산합니다.

00:27:51.629 --> 00:27:58.620
얼음 경계(frozen boundary) 셀의 일부가 
눈송이의 몸체에 붙습니다. 그리고 그중 일부는 녹아내립니다.

00:27:58.620 --> 00:28:03.539
마지막으로는 제가 생각하기에 정말 아름답다고 생각이 드는 
파라미터인 노이즈(noise) 입니다.

00:28:03.539 --> 00:28:08.559
전체 시뮬레이션에 약간의 무작위성을 추가합니다. 

00:28:08.559 --> 00:28:14.570
그리고 최종 완성하게 되는 것은 완벽하게 대칭되는 
눈송이가 아니라 눈송이 가지에 약간의 흠이 있는

00:28:14.570 --> 00:28:17.999
눈송이입니다.

00:28:17.999 --> 00:28:23.340
그리드 관점에서 보면 시뮬레이션이 진행됨에 따라

00:28:23.340 --> 00:28:25.450
눈송이의 결정이 처음 시드(seed)에서부터 
시작하는 것을 알 수 있습니다.

00:28:25.450 --> 00:28:33.149
그래서 가운데 얼음(frozen) 상태와 
주위에 있는 경계(boundary)의 시드(seed)들을 볼 수 있습니다.

00:28:33.149 --> 00:28:35.529
이 프로그램은 
세포 자동자(cellular automata) 시뮬레이션처럼 동작합니다.

00:28:35.529 --> 00:28:41.640
각 셀은 이웃 된 셀을 확인하고 
매개 변수를 기반으로 변경 사항을 연산합니다.

00:28:41.640 --> 00:28:45.860
하지만 수십만 개의 셀이 있어서 
시뮬레이션은 엄청난 연산을 하게 되고

00:28:45.860 --> 00:28:48.919
실행 시간이 오래 걸립니다.

00:28:48.919 --> 00:28:52.909
저와 제 여자친구는 선물로 만든 
100개의 눈송이를 만들기 위해 

00:28:52.909 --> 00:28:56.330
실제로 구름 속의 모든 종류의 눈송이를 만들었습니다.

00:28:56.330 --> 00:29:03.409
[웃음과 박수]

00:29:03.409 --> 00:29:07.450
이 시뮬레이션의 결과는 복잡한 비트맵입니다.

00:29:07.450 --> 00:29:14.379
데카르트(Cartesian) 그리드에서 
빨강, 녹색, 파랑 농도를 캡처하는 대신

00:29:14.379 --> 00:29:19.979
이 비트맵은 육각형 격자 안의 
얼어버린 물 분자의 밀도를 계산합니다.

00:29:19.979 --> 00:29:24.850
눈송이가 미리 설정해 둔 크기가 되면
시뮬레이션은 종료하고 프로그램에서는

00:29:24.850 --> 00:29:26.119
해당 눈송이를 SVG 파일로 변환합니다.

00:29:26.119 --> 00:29:31.379
2개의 SVG 파일이 생성되고 1개로 병합됩니다.

00:29:31.379 --> 00:29:38.179
첫 번째 SVG 파일은 결빙된 물 분자의 밀도가 가장 높은 밴드를

00:29:38.179 --> 00:29:40.809
냅니다.

00:29:40.809 --> 00:29:50.960
그곳이 가장 흔하게 물이 얼어 버리는 지점입니다.

00:29:50.960 --> 00:29:57.570
그리고 여러분이 볼 수 있는 이러한 밀도의 밴드가 있습니다.
두 번째 SVG는 실제로 눈송이의 윤곽을 정의합니다.

00:29:57.570 --> 00:30:04.309
2개의 파일은 1개의 SVG로 병합된 다음 
레이저 커터로 전송됩니다.

00:30:04.309 --> 00:30:09.830
여기에 이 모든 과정을 보여주는 멋진 영상이 있습니다.

00:30:09.830 --> 00:30:19.889
이 모델의 정말 놀라운 한 가지는

00:30:19.889 --> 00:30:26.909
다양 한 종류의 눈송이를 생성할 수 있다는 점입니다. 
그리고, 여러분도 보셨다시피, 마지막으로 보셨던 것과
같아 보이는 것은 

00:30:26.909 --> 00:30:28.879
하나도 없습니다.

00:30:28.879 --> 00:30:35.229
그래서 저는 눈송이가 만들어지는 모든 단계의 과정을 
이미지로 저장하는 시뮬레이션을 실행했습니다.

00:30:35.229 --> 00:30:39.139
이것은 전체 눈송이가 만들어지는 과정입니다.

00:30:39.139 --> 00:30:46.590
주위에 검은색의 아우라를 볼 수 있습니다. 
그리고 회색 영역은 여전히 수증기성 물이지만

00:30:46.590 --> 00:30:58.369
그것은 실제로 눈송이의 중심으로 빨려 들어가서 
고갈되는 수증기입니다.

00:30:58.369 --> 00:31:01.519
여기서 우리는 눈송이 중 하나를 에칭하고 자르고 있습니다.

00:31:01.519 --> 00:31:07.719
그래서 여기 레이저 커터가 에칭 모드로 되어 있다는 것을 
알 수 있습니다.

00:31:07.719 --> 00:31:13.259
레이저 커터는 단지 플라스틱의 표면을 벗겨내어 
플라스틱을 움푹 파이게 만들뿐
플라스틱을 잘라내지는 않습니다.

00:31:13.259 --> 00:31:19.460
그리고 그것이 끝나면, 자르는 단계를 수행하여

00:31:19.460 --> 00:31:25.549
눈송이를 (만들기 위한 부분을 남기고 나머지를) 제거합니다. 
그리고 저는 많은 예제를 가져왔는데,

00:31:25.549 --> 00:31:31.070
원하신다면, 
발표 후에 와서 보실 수 있습니다.

00:31:31.070 --> 00:31:39.279
제가 보여 드리고 싶은 또 다른 예는 
제가 로켓이라고 불러왔던 것입니다.

00:31:39.279 --> 00:31:46.200
이것은 모델 로켓 구성 키트이고,
일종의 첫 번째 프로젝트입니다.

00:31:46.200 --> 00:31:51.489
저는 OpenSCAD와 python으로 구현했습니다. 
그리고 뭔가 기능적으로 만들고 싶었습니다.

00:31:51.489 --> 00:31:55.769
맞습니다. 
저는 프린터로 뭔가를 인쇄해서 만들어 내고 싶었고,

00:31:55.769 --> 00:31:56.769
실제로 인쇄할 수 있기를 바랐습니다.

00:31:56.769 --> 00:32:07.619
그래서 저는 다양한 크기와 타입의 로켓을 설계할 수 있는
로켓 모델 생성기를

00:32:07.619 --> 00:32:10.110
만들었습니다.

00:32:10.110 --> 00:32:15.719
로켓 모델에 익숙하지 않으시다면
우선은 엔진의 크기가 다양하다는 것을 아셔야 합니다.

00:32:15.719 --> 00:32:21.929
이 엔진은 골판지 튜프에 포장된 고체 추진제로 만들어져

00:32:21.929 --> 00:32:23.980
있습니다.

00:32:23.980 --> 00:32:29.090
로켓 모델 엔진의 크기, 길이, 지름이 다양해서 
설계를 시작할 때, 

00:32:29.090 --> 00:32:32.749
다양한 크기의 엔진 홀더가 필요합니다.

00:32:32.749 --> 00:32:37.889
설계를 시작할 때 먼저 엔진을 선택한 다음,
로켓은 엔진의 크기에 따라

00:32:37.889 --> 00:32:45.700
로켓에 대한 다양한 매개 변수를 연산합니다.

00:32:45.700 --> 00:32:51.369
로켓 모델의 또 다른 좋은 특징은 커플링 슬리브를 사용하여

00:32:51.369 --> 00:32:54.759
레고처럼 로켓을 맞출 수 있다는 것입니다.

00:32:54.759 --> 00:33:00.659
이것을 여러분의 프린터로 인쇄할 수가 있고,
손쉽게 합쳐서

00:33:00.659 --> 00:33:01.659
발사할 수 있습니다.

00:33:01.659 --> 00:33:09.649
하지만 로켓이 하늘로 올라갈 때 분리되어 버릴 수 있어서
접착제를 사용하여 합치는 것이 좋습니다. 

00:33:09.649 --> 00:33:17.049
여러분은 몸체(coupling sleeve)를 3D 프린터로 인쇄할 수 있고
이것으로 다단 로켓을 만들 수도 

00:33:17.049 --> 00:33:21.840
있습니다.

00:33:21.840 --> 00:33:26.019
로켓은 설계의 여러 부분을 쉽게 바꿀 수 있습니다.

00:33:26.019 --> 00:33:31.529
예를 들어, 여러 종류의 로켓 머리(nose cone)를 바꾸거나
로켓의 꼬리(fins)를 추가하거나 제거할 수 있습니다.

00:33:31.529 --> 00:33:36.889
또는 제가 가장 좋아하는 기능 중 하나인 
로켓 꼬리(fins)를 기울여서 로켓이 발사될 때

00:33:36.889 --> 00:33:40.519
하늘로 올라가게 하는 것입니다.

00:33:40.519 --> 00:33:44.269
하지만 이것에 대해 정말 멋지다고 생각하는 것은 
두 개의 매우 비슷하게 설계된 로켓을 
인쇄할 수 있다는 것입니다.

00:33:44.269 --> 00:33:49.300
그 둘 간에 약간의 수정은 있을 수 있지만

00:33:49.300 --> 00:33:50.950
쉽게 다시 만들어 낼 수 있습니다.

00:33:50.950 --> 00:34:01.519
그래서 수정된 설계의 성능을 직접 확인할 수 있습니다.

00:34:01.519 --> 00:34:09.300
제 친구인 Adam은
이 첫 번째 영상을 녹화했습니다. 

00:34:09.300 --> 00:34:13.210
불행히도 유일한 비디오 장면이며, 형편없는 발사입니다.

00:34:13.210 --> 00:34:14.210
그러나 그것은 동작했었습니다.

00:34:14.210 --> 00:34:21.060
저는 이것이 나선형인 로켓 중 하나라고 생각됩니다.
그래서 이것은 하늘에 나선형으로 올라갔습니다.

00:34:21.060 --> 00:34:29.810
그러나 엔진 크기에 대한 무게 비율은 보정하지 않았었습니다.

00:34:29.810 --> 00:34:37.720
그래서 금세 로켓 머리가 꼬꾸라지기 시작했습니다.
하지만 이 부분이 가장 중요한 부분입니다.

00:34:37.720 --> 00:34:40.670
솔직히 말씀드리면 이 로켓은 튼튼하지 않습니다.

00:34:40.670 --> 00:34:47.220
이것은 플라스틱이고 
플라스틱은 열을 좋아하지 않기 때문에 녹을 가능성이 높지만

00:34:47.220 --> 00:34:48.220
아무도 신경 쓰지 않습니다.

00:34:48.220 --> 00:34:49.690
집에 가서 더 인쇄하면 되니까요.

00:34:49.690 --> 00:34:52.003
분명 여러분은 적어도 몇 번의 로켓을 날려보는 것만으로
적절한 값을 얻을 수 있습니다.

00:34:52.003 --> 00:34:58.740
여러분이 3D 프린터로 뭔가를 인쇄하고 

00:34:58.740 --> 00:35:02.760
프린터에서 꺼내서 로켓 엔진을 넣으면 하늘로 날아간다는 것은 
너무 멋지다는 생각이 듭니다.

00:35:02.760 --> 00:35:13.120
어쨌든, 여러분은 스스로 의문이 생길지 모릅니다.
어떻게 이 도구들을 접할 수 있는지에 대해서요.

00:35:13.120 --> 00:35:22.561
저는 모든 사람이 (이 3D 프린터로 인쇄된 물건을) 
폐기할 수 있는 지역에 있지 않다는 사실을 깨닫게 되었습니다.

00:35:22.561 --> 00:35:27.590
제가 사는 보스턴은 3D 프린터 및 레이저 커터를 
사용할 수 있는 지역별 제작 공간이 여럿 있습니다.

00:35:27.590 --> 00:35:32.840
일부 공공 도서관은 이러한 도구들을 사용할 수 있도록 
자체 제작 공간을

00:35:32.840 --> 00:35:35.260
두고 있습니다.

00:35:35.260 --> 00:35:40.390
만약 살고 계신 지역에서 아무것도 찾을 수 없는 경우,
Ponoko, ShapeWay같이 인기 있는 인터넷 기반 서비스를 
사용할 수 있습니다.

00:35:40.390 --> 00:35:46.830
예를 들면, 저는 이 발표를 하러 오기 전에 
(레이저 커팅 할)모든 것들을 

00:35:46.830 --> 00:35:50.980
Ponoko를 이용해서 커팅했습니다.

00:35:50.980 --> 00:35:55.480
그러나 모든 분야는 정말로 빠르게 변화하고 있고
새로운 도구가 매년 나오고 있습니다.

00:35:55.480 --> 00:36:03.720
이러한 도구가 발전함에 따라서
이 도구들을 소유하고 있는 비용은 낮아집니다.

00:36:03.720 --> 00:36:09.520
이것들은 제가 작성한 모든 다양한 소스코드가 있는
Github URL입니다.

00:36:09.520 --> 00:36:14.410
가장 위의 것은 이 발표의 미러 링크 주소입니다.

00:36:14.410 --> 00:36:19.080
하지만 제가 만든 
눈송이 생성기, 로켓 생성기 및 Python SCAD 라이브러리도

00:36:19.080 --> 00:36:21.660
찾을 수 있습니다.

00:36:21.660 --> 00:36:22.870
여기까지입니다.

00:36:22.870 --> 00:36:25.630
대단히 감사합니다.

00:36:25.630 --> 00:36:27.850
[박수와 갈채]

00:36:27.850 --> 00:36:37.510
잠시 질문을 받겠습니다.

00:36:37.510 --> 00:36:41.510
마이크 갖고 계신 분은 
마이크를 앞쪽으로 가지고 와주시기 바랍니다.

00:36:41.510 --> 00:36:47.450
왜 당신이 화분을 거꾸로 인쇄하지 않았는지 궁금합니다.

00:36:47.450 --> 00:36:50.560
좋은 질문입니다.

00:36:50.560 --> 00:37:02.640
이유는 화분 바닥의 평탄도가 화분 입구와는 대조적으로
튀어나오기 때문입니다.

00:37:02.640 --> 00:37:07.880
솔직히 말씀드리자면, 아마 6:1일 것입니다. 
(it's probably six of one half-dozen of the other)

00:37:07.880 --> 00:37:12.340
그러나 당신은 그것이 화분의 중심에 
화분을 인쇄해야 한다고 생각하실 겁니다.

00:37:12.340 --> 00:37:19.310
그리고 보조제(support material)를 찢는 것보다 
파서 꺼내는 것이 더 어렵기 때문입니다.

00:37:19.310 --> 00:37:24.250
그래서 저는 정방향을 선택했습니다.

00:37:24.250 --> 00:37:30.160
질문이 없으시면 발표자에게 다시 감사의 인사를 전해드립니다.
